├── .changeset
    ├── README.md
    └── config.json
├── .github
    └── workflows
    │   ├── ci.yml
    │   ├── coverage.yml
    │   └── release.yml
├── .gitignore
├── .vscode
    ├── extensions.json
    ├── launch.json
    └── settings.json
├── CONTRIBUTING.md
├── LICENSE
├── README.md
├── biome.json
├── package.json
├── packages
    ├── _test-vectors
    │   ├── index.ts
    │   ├── mockedBoxes.ts
    │   ├── mockedGraphQLBoxResponses.json
    │   ├── mockedGraphQLTxResponse.json
    │   └── mockedTransactions.ts
    ├── blockchain-providers
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── ergo-graphql
    │   │       ├── ergoGraphQLProvider.spec.ts
    │   │       ├── ergoGraphQLProvider.ts
    │   │       ├── queries.spec.ts
    │   │       └── queries.ts
    │   │   ├── index.ts
    │   │   ├── types
    │   │       └── blockchainProvider.ts
    │   │   └── utils
    │   │       ├── _tests.ts
    │   │       ├── graphql.spec.ts
    │   │       ├── graphql.test-d.ts
    │   │       ├── graphql.ts
    │   │       ├── index.ts
    │   │       ├── networking.spec.ts
    │   │       └── networking.ts
    ├── common
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── error.spec.ts
    │   │   ├── error.ts
    │   │   ├── index.ts
    │   │   ├── models
    │   │       ├── collection.spec.ts
    │   │       └── collection.ts
    │   │   ├── types
    │   │       ├── block.ts
    │   │       ├── boxes.ts
    │   │       ├── common.ts
    │   │       ├── enums.ts
    │   │       ├── index.ts
    │   │       ├── inputs.ts
    │   │       ├── registers.ts
    │   │       ├── token.ts
    │   │       └── transactions.ts
    │   │   └── utils
    │   │       ├── array.spec.ts
    │   │       ├── array.ts
    │   │       ├── assertions.spec.ts
    │   │       ├── assertions.ts
    │   │       ├── bigInt.spec.ts
    │   │       ├── bigInt.ts
    │   │       ├── bytes.bench.ts
    │   │       ├── bytes.spec.ts
    │   │       ├── bytes.ts
    │   │       ├── index.ts
    │   │       ├── object.spec.ts
    │   │       ├── object.ts
    │   │       ├── utxo.spec.ts
    │   │       └── utxo.ts
    ├── compiler
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   ├── sigmastate-js.d.ts
    │   └── src
    │   │   ├── compiler.spec.ts
    │   │   ├── compiler.ts
    │   │   ├── compilerOutput.ts
    │   │   ├── contractTemplate.ts
    │   │   └── index.ts
    ├── core
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── builder
    │   │       ├── index.ts
    │   │       ├── outputBuilder.spec.ts
    │   │       ├── outputBuilder.test-d.ts
    │   │       ├── outputBuilder.ts
    │   │       ├── pluginContext.spec.ts
    │   │       ├── pluginContext.ts
    │   │       ├── selector
    │   │       │   ├── boxSelector.spec.ts
    │   │       │   ├── boxSelector.ts
    │   │       │   ├── index.ts
    │   │       │   └── strategies
    │   │       │   │   ├── ISelectionStrategy.ts
    │   │       │   │   ├── accumulativeSelectionStrategy.spec.ts
    │   │       │   │   ├── accumulativeSelectionStrategy.ts
    │   │       │   │   ├── cherryPickSelectionStrategy.spec.ts
    │   │       │   │   ├── cherryPickSelectionStrategy.ts
    │   │       │   │   ├── customSelectionStrategy.spec.ts
    │   │       │   │   └── customSelectionStrategy.ts
    │   │       ├── transactionBuilder.spec.ts
    │   │       ├── transactionBuilder.ts
    │   │       ├── transactionBuilderSettings.spec.ts
    │   │       └── transactionBuilderSettings.ts
    │   │   ├── constantSerializer.spec.ts
    │   │   ├── constantSerializer.ts
    │   │   ├── errors
    │   │       ├── duplicateInputError.ts
    │   │       ├── duplicateInputSelectionError.ts
    │   │       ├── index.ts
    │   │       ├── insufficientInputs.spec.ts
    │   │       ├── insufficientInputs.ts
    │   │       ├── insufficientTokenAmount.ts
    │   │       ├── invalidAddress.ts
    │   │       ├── invalidInput.ts
    │   │       ├── invalidRegistersPacking.ts
    │   │       ├── malformedTransaction.ts
    │   │       ├── maxTokensOverflow.ts
    │   │       ├── nonStandardizedMinting.ts
    │   │       ├── notAllowedTokenBurning.ts
    │   │       ├── notFoundError.ts
    │   │       ├── undefinedCreationHeight.ts
    │   │       └── undefinedMintingContext.ts
    │   │   ├── index.ts
    │   │   ├── models
    │   │       ├── collections
    │   │       │   ├── index.ts
    │   │       │   ├── inputsCollection.spec.ts
    │   │       │   ├── inputsCollection.ts
    │   │       │   ├── outputsCollection.spec.ts
    │   │       │   ├── outputsCollection.ts
    │   │       │   ├── tokensCollection.spec.ts
    │   │       │   └── tokensCollection.ts
    │   │       ├── ergoAddress.spec.ts
    │   │       ├── ergoAddress.ts
    │   │       ├── ergoBox.spec.ts
    │   │       ├── ergoBox.ts
    │   │       ├── ergoBoxCandidate.ts
    │   │       ├── ergoMessage.spec.ts
    │   │       ├── ergoMessage.ts
    │   │       ├── ergoTree.spec.ts
    │   │       ├── ergoTree.ts
    │   │       ├── ergoUnsignedInput.spec.ts
    │   │       ├── ergoUnsignedInput.ts
    │   │       ├── ergoUnsignedTransaction.spec.ts
    │   │       ├── ergoUnsignedTransaction.ts
    │   │       ├── ergoUnsignedTransactionChain.ts
    │   │       ├── index.ts
    │   │       ├── utils.spec.ts
    │   │       └── utils.ts
    │   │   └── tests
    │   │       └── testVectors
    │   │           └── ergoAddressesTestVectors.ts
    ├── crypto
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── coders
    │   │       ├── bigintBE.spec.ts
    │   │       ├── bigintBE.ts
    │   │       ├── hex.bench.ts
    │   │       ├── hex.spec.ts
    │   │       ├── hex.ts
    │   │       ├── index.spec.ts
    │   │       ├── index.ts
    │   │       ├── utf8.spec.ts
    │   │       └── utf8.ts
    │   │   ├── ecpoint.spec.ts
    │   │   ├── ecpoint.ts
    │   │   ├── hashes.spec.ts
    │   │   ├── hashes.ts
    │   │   ├── index.ts
    │   │   └── types.ts
    ├── mock-chain
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── balancePrinting.spec.ts
    │   │   ├── balancePrinting.ts
    │   │   ├── execution.spec.ts
    │   │   ├── execution.ts
    │   │   ├── index.ts
    │   │   ├── mockChain.spec.ts
    │   │   ├── mockChain.ts
    │   │   ├── mockUtxoCollection.spec.ts
    │   │   ├── mockUtxoCollection.ts
    │   │   ├── objectMocking.spec.ts
    │   │   ├── objectMocking.ts
    │   │   ├── party
    │   │       ├── index.ts
    │   │       ├── keyedMockChainParty.spec.ts
    │   │       ├── keyedMockChainParty.ts
    │   │       ├── mockChainParty.ts
    │   │       ├── nonKeyedMockChainParty.spec.ts
    │   │       └── nonKeyedMockChainParty.ts
    │   │   └── sigmastate.d.ts
    ├── serializer
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── _test-vectors
    │   │       ├── boxVectors.ts
    │   │       ├── constantVectors.ts
    │   │       └── transactionVectors.ts
    │   │   ├── coders
    │   │       ├── bigint.spec.ts
    │   │       ├── bigint.ts
    │   │       ├── index.ts
    │   │       ├── numRanges.ts
    │   │       ├── sigmaByteReader.ts
    │   │       ├── sigmaByteWriter.spec.ts
    │   │       ├── sigmaByteWriter.ts
    │   │       ├── vlq.spec.ts
    │   │       ├── vlq.ts
    │   │       ├── zigZag.spec.ts
    │   │       └── zigZag.ts
    │   │   ├── index.ts
    │   │   ├── serializers
    │   │       ├── boxSerializer.spec.ts
    │   │       ├── boxSerializer.ts
    │   │       ├── dataSerializer.ts
    │   │       ├── index.ts
    │   │       ├── transactionSerializer.spec.ts
    │   │       ├── transactionSerializer.ts
    │   │       └── typeSerializer.ts
    │   │   ├── sigmaConstant.spec.ts
    │   │   ├── sigmaConstant.ts
    │   │   └── types
    │   │       ├── base.ts
    │   │       ├── constructors.spec.ts
    │   │       ├── constructors.test-d.ts
    │   │       ├── constructors.ts
    │   │       ├── descriptors.spec.ts
    │   │       ├── descriptors.ts
    │   │       ├── generics.ts
    │   │       ├── index.ts
    │   │       ├── monomorphics.ts
    │   │       └── primitives.ts
    └── wallet
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │       ├── _test-vectors
    │           └── keyVectors.ts
    │       ├── ergoHDKey.spec.ts
    │       ├── ergoHDKey.ts
    │       ├── index.ts
    │       ├── mnemonic.spec.ts
    │       ├── mnemonic.ts
    │       ├── prover
    │           ├── proveDLogProtocol.spec.ts
    │           ├── proveDLogProtocol.ts
    │           ├── prover.spec.ts
    │           └── prover.ts
    │       ├── wordlists.spec.ts
    │       └── wordlists.ts
├── plugins
    ├── ageusd
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │   │   ├── _tests
    │   │       └── mocking.ts
    │   │   ├── ageUsdBank.spec.ts
    │   │   ├── ageUsdBank.ts
    │   │   ├── exchangePlugin.spec.ts
    │   │   ├── exchangePlugin.ts
    │   │   ├── index.ts
    │   │   ├── sigmaUsdBank.spec.ts
    │   │   ├── sigmaUsdBank.ts
    │   │   └── sigmaUsdParameters.ts
    └── babel-fees
    │   ├── CHANGELOG.md
    │   ├── LICENSE
    │   ├── README.md
    │   ├── package.json
    │   └── src
    │       ├── _test-vectors
    │           └── babelContractsVectors.ts
    │       ├── constants.ts
    │       ├── index.ts
    │       ├── plugins.spec.ts
    │       ├── plugins.ts
    │       ├── utils.spec.ts
    │       └── utils.ts
├── pnpm-lock.yaml
├── pnpm-workspace.yaml
├── tsconfig.json
├── tsup.config.ts
└── vitest.config.ts


/.changeset/README.md:
--------------------------------------------------------------------------------
1 | # Changesets
2 | 
3 | Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
4 | with multi-package repos, or single-package repos to help you version and publish your code. You can
5 | find the full documentation for it [in our repository](https://github.com/changesets/changesets)
6 | 
7 | We have a quick list of common questions to get you started engaging with this project in
8 | [our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)
9 | 


--------------------------------------------------------------------------------
/.changeset/config.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "$schema": "https://unpkg.com/@changesets/config@2.3.0/schema.json",
 3 |   "changelog": "@changesets/cli/changelog",
 4 |   "commit": false,
 5 |   "fixed": [],
 6 |   "linked": [
 7 |     [
 8 |       "*/core",
 9 |       "*/common",
10 |       "*/crypto",
11 |       "*/serializer",
12 |       "*/mock-chain",
13 |       "*/compiler",
14 |       "*/wallet",
15 |       "*/blockchain-providers"
16 |     ]
17 |   ],
18 |   "access": "public",
19 |   "baseBranch": "master",
20 |   "updateInternalDependencies": "patch"
21 | }
22 | 


--------------------------------------------------------------------------------
/.github/workflows/coverage.yml:
--------------------------------------------------------------------------------
 1 | name: Coverage
 2 | 
 3 | on:
 4 |   pull_request:
 5 |   push:
 6 |     branches:
 7 |       - "master"
 8 |     tags:
 9 |       - "!**"
10 | 
11 | jobs:
12 |   coverage:
13 |     name: Check and submit
14 |     runs-on: ubuntu-latest
15 |     steps:
16 |       - uses: actions/checkout@v4
17 | 
18 |       - uses: pnpm/action-setup@v4
19 |         with:
20 |           version: 9
21 | 
22 |       - name: Collect coverage
23 |         uses: actions/setup-node@v4
24 |         with:
25 |           node-version: 20
26 |           cache: "pnpm"
27 |       - run: pnpm install --frozen-lockfile
28 |       - run: pnpm -r build
29 |       - run: pnpm run cov:check
30 | 
31 |       - name: Submit report
32 |         if: success() || failure()
33 |         uses: codecov/codecov-action@v4
34 |         with:
35 |           token: ${{ secrets.CODECOV_TOKEN }}
36 |           files: ./coverage/coverage-final.json
37 | 


--------------------------------------------------------------------------------
/.github/workflows/release.yml:
--------------------------------------------------------------------------------
 1 | name: Release
 2 | 
 3 | on:
 4 |   push:
 5 |     branches:
 6 |       - master
 7 | 
 8 | concurrency: ${{ github.workflow }}-${{ github.ref }}
 9 | 
10 | jobs:
11 |   release:
12 |     name: Release
13 |     runs-on: ubuntu-latest
14 | 
15 |     permissions:
16 |       contents: write # to be able to publish a GitHub release
17 |       issues: write # to be able to comment on released issues
18 |       pull-requests: write # to be able to comment on released pull requests
19 |       id-token: write # to enable use of OIDC for npm provenance
20 | 
21 |     steps:
22 |       - name: Checkout Repo
23 |         uses: actions/checkout@v4
24 | 
25 |       - uses: pnpm/action-setup@v4
26 |         with:
27 |           version: 9
28 | 
29 |       - name: Setup Node.js 20.x
30 |         uses: actions/setup-node@v4
31 |         with:
32 |           node-version: 20
33 |           cache: "pnpm"
34 | 
35 |       - name: Ensure latest npm version to be installed for npm provenance support
36 |         run: npm install -g npm
37 | 
38 |       - name: Install Dependencies
39 |         run: pnpm install --frozen-lockfile
40 | 
41 |       - name: Create Release Pull Request or Publish to npm
42 |         id: changesets
43 |         uses: changesets/action@v1
44 |         with:
45 |           publish: pnpm run ci:publish
46 |           createGithubReleases: true
47 |         env:
48 |           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
49 |           NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
50 |           NPM_CONFIG_PROVENANCE: true
51 | 


--------------------------------------------------------------------------------
/.gitignore:
--------------------------------------------------------------------------------
 1 | .idea/*
 2 | .nyc_output
 3 | node_modules
 4 | test
 5 | src/**.js
 6 | coverage
 7 | *.log
 8 | yarn.lock
 9 | .DS_Store
10 | .npmrc
11 | dist


--------------------------------------------------------------------------------
/.vscode/extensions.json:
--------------------------------------------------------------------------------
1 | {
2 |   "recommendations": [
3 |     "biomejs.biome",
4 |     "streetsidesoftware.code-spell-checker",
5 |     "vitest.explorer"
6 |   ]
7 | }
8 | 


--------------------------------------------------------------------------------
/.vscode/launch.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "version": "0.2.0",
 3 |   "configurations": [
 4 |     {
 5 |       "type": "node",
 6 |       "request": "launch",
 7 |       "name": "Debug Current Test File",
 8 |       "autoAttachChildProcesses": true,
 9 |       "skipFiles": ["<node_internals>/**", "**/node_modules/**"],
10 |       "program": "${workspaceRoot}/node_modules/vitest/vitest.mjs",
11 |       "args": ["run", "${relativeFile}"],
12 |       "smartStep": true,
13 |       "console": "integratedTerminal"
14 |     }
15 |   ]
16 | }
17 | 


--------------------------------------------------------------------------------
/.vscode/settings.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "explorer.fileNesting.enabled": true,
 3 |   "explorer.fileNesting.patterns": {
 4 |     "*.ts": "${capture}.*.ts, ${capture}.js"
 5 |   },
 6 |   "[typescript]": {
 7 |     "editor.defaultFormatter": "biomejs.biome"
 8 |   }
 9 | }
10 | 


--------------------------------------------------------------------------------
/CONTRIBUTING.md:
--------------------------------------------------------------------------------
 1 | # Fleet SDK Contributing Guide
 2 | 
 3 | Hi! We're really excited that you're interested in contributing to Fleet SDK! Before submitting your contribution, please read through the following guide.
 4 | 
 5 | ## Repo Setup
 6 | 
 7 | The Fleet SDK repo is a monorepo using pnpm workspaces. The package manager used to install and link dependencies must be [pnpm](https://pnpm.io/).
 8 | 
 9 | In `fleet`'s root directory, run the following commands:
10 | 
11 | 1. `pnpm install` to install dependencies.
12 | 
13 | 2. `pnpm -r build` to build all packages.
14 | 
15 | 3. `pnpm watch:unit core` to run unit tests in watch mode.
16 | 
17 | > 💡 If you use VS Code, you can hit `⇧ ⌘ B` or `Ctrl + Shift + B` to launch all the necessary dev tasks.
18 | 
19 | We recommend installing [ni](https://github.com/antfu/ni) to help switching between repos using different package managers, but that's totally optional. `ni` also provides the handy `nr` command which running npm scripts easier:
20 | 
21 | - `ni` is equivalent to `pnpm install`.
22 | - `nr test` is equivalent to `pnpm test`.
23 | 
24 | ## Pull Request Guidelines
25 | 
26 | - Checkout a topic branch from a base branch, e.g. `master`, and merge back against that branch.
27 | 
28 | - If adding a new feature:
29 | 
30 |   - Add accompanying test case.
31 |   - Provide a convincing reason to add this feature. Ideally, you should open a suggestion issue first and have it approved before working on it.
32 | 
33 | - If fixing a bug:
34 | 
35 |   - Provide a detailed description of the bug in the PR.
36 |   - Add appropriate test coverage if applicable.
37 | 
38 | - It's OK to have multiple small commits as you work on the PR - GitHub can automatically squash them before merging.
39 | 
40 | - Make sure tests pass!
41 | 
42 | - Use `pnpm fix` to format files according to the project guidelines.
43 | 
44 | ### Dependencies
45 | 
46 | Fleet SDK aims to be lightweight, which involves being conscious of the number of npm dependencies and their size.
47 | 
48 | - Avoid dependencies with large transitive dependencies that result in bloated size in comparison to their provided functionality.
49 | 
50 | ### Coverage
51 | 
52 | Fleet SDK is a security-critical tool. Therefore, it is essential to ensure everything is working as expected. Besides a conservative development approach and careful implementations, Fleet SDK aims to ensure that 100% of the code is covered by unit tests.


--------------------------------------------------------------------------------
/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/biome.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "$schema": "https://biomejs.dev/schemas/1.8.2/schema.json",
 3 |   "files": {
 4 |     "ignore": [
 5 |       "**/coverage/*",
 6 |       "**/dist/*",
 7 |       "**/node_modules/*",
 8 |       "./packages/_test-vectors/mockedGraphQLBoxResponses.json",
 9 |       "./packages/_test-vectors/mockedGraphQLTxResponse.json",
10 |       "**/package.json"
11 |     ]
12 |   },
13 |   "organizeImports": {
14 |     "enabled": true
15 |   },
16 |   "formatter": {
17 |     "indentStyle": "space",
18 |     "lineWidth": 90
19 |   },
20 |   "javascript": {
21 |     "formatter": {
22 |       "trailingCommas": "none"
23 |     }
24 |   },
25 |   "linter": {
26 |     "enabled": true,
27 |     "ignore": ["**/sigmastate*.d.ts"],
28 |     "rules": {
29 |       "recommended": true,
30 |       "style": {
31 |         "noParameterAssign": { "level": "off" }
32 |       },
33 |       "suspicious": {
34 |         "noConsoleLog": { "level": "error" },
35 |         "noAssignInExpressions": { "level": "off" }
36 |       }
37 |     }
38 |   }
39 | }
40 | 


--------------------------------------------------------------------------------
/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "private": "true",
 3 |   "repository": "github:fleet-sdk/fleet",
 4 |   "license": "MIT",
 5 |   "type": "module",
 6 |   "scripts": {
 7 |     "clear": "pnpm -r exec rm -rf dist",
 8 |     "fix": "run-s fix:*",
 9 |     "test": "run-s test:*",
10 |     "watch:unit": "vitest --no-coverage --reporter=dot",
11 |     "watch:types": "vitest typecheck --reporter=dot",
12 |     "ci:publish": "pnpm clear && pnpm -r build && changeset publish --provenance",
13 |     "fix:format": "biome format --write",
14 |     "fix:lint": "biome lint --write",
15 |     "test:lint": "biome lint",
16 |     "test:format": "biome format",
17 |     "test:unit": "vitest run --no-coverage --environment=node",
18 |     "test:unit-browser": "vitest run --no-coverage --environment=happy-dom",
19 |     "test:unit-edge": "vitest run --no-coverage --environment=edge-runtime",
20 |     "cov:check": "vitest run --coverage",
21 |     "cov:open": "vitest run --coverage ; open-cli coverage/index.html",
22 |     "bench": "vitest bench",
23 |     "snapshot:version": "changeset version --snapshot snapshot",
24 |     "snapshot:publish": "pnpm clear && pnpm -r build && changeset publish --no-git-tag --tag snapshot"
25 |   },
26 |   "devDependencies": {
27 |     "@biomejs/biome": "^1.9.4",
28 |     "@changesets/cli": "^2.27.12",
29 |     "@edge-runtime/vm": "^5.0.0",
30 |     "@fleet-sdk/common": "workspace:^",
31 |     "@fleet-sdk/crypto": "workspace:^",
32 |     "@types/diff": "^7.0.1",
33 |     "@vitest/coverage-v8": "^3.0.5",
34 |     "ergo-lib-wasm-nodejs": "^0.28.0",
35 |     "fast-check": "^3.23.2",
36 |     "happy-dom": "^16.8.1",
37 |     "npm-run-all": "^4.1.5",
38 |     "open-cli": "^8.0.0",
39 |     "sigmastate-js": "0.4.6",
40 |     "tsup": "^8.3.6",
41 |     "type-fest": "^4.33.0",
42 |     "typescript": "^5.7.3",
43 |     "vite-tsconfig-paths": "^5.1.4",
44 |     "vitest": "^3.0.5"
45 |   },
46 |   "engines": {
47 |     "node": ">=18",
48 |     "pnpm": ">=8"
49 |   },
50 |   "pnpm": {
51 |     "requiredScripts": [
52 |       "build"
53 |     ]
54 |   }
55 | }
56 | 


--------------------------------------------------------------------------------
/packages/_test-vectors/index.ts:
--------------------------------------------------------------------------------
1 | import _gqlBoxes from "./mockedGraphQLBoxResponses.json";
2 | import _gqlTransactions from "./mockedGraphQLTxResponse.json";
3 | 
4 | export * from "./mockedBoxes";
5 | export * from "./mockedTransactions";
6 | export const mockedGraphQLBoxes = _gqlBoxes;
7 | export const mockedGraphQLTransactions = _gqlTransactions;
8 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/CHANGELOG.md:
--------------------------------------------------------------------------------
  1 | # @fleet-sdk/blockchain-providers
  2 | 
  3 | ## 0.8.2
  4 | 
  5 | ### Patch Changes
  6 | 
  7 | - @fleet-sdk/core@0.8.2
  8 | 
  9 | ## 0.8.1
 10 | 
 11 | ### Patch Changes
 12 | 
 13 | - Updated dependencies [c0a3d35]
 14 | - Updated dependencies [c0a3d35]
 15 |   - @fleet-sdk/core@0.8.1
 16 | 
 17 | ## 0.8.0
 18 | 
 19 | ### Patch Changes
 20 | 
 21 | - Updated dependencies [9f8b5ee]
 22 | - Updated dependencies [36adc61]
 23 |   - @fleet-sdk/core@0.8.0
 24 |   - @fleet-sdk/common@0.8.0
 25 | 
 26 | ## 0.7.0
 27 | 
 28 | ### Patch Changes
 29 | 
 30 | - Updated dependencies [a08a573]
 31 |   - @fleet-sdk/core@0.7.0
 32 | 
 33 | ## 0.6.5
 34 | 
 35 | ### Patch Changes
 36 | 
 37 | - 76998dd: Fix `relevantOnly` query var
 38 | 
 39 | ## 0.6.4
 40 | 
 41 | ### Patch Changes
 42 | 
 43 | - Updated dependencies [504974e]
 44 |   - @fleet-sdk/common@0.6.4
 45 |   - @fleet-sdk/core@0.6.4
 46 | 
 47 | ## 0.6.3
 48 | 
 49 | ### Patch Changes
 50 | 
 51 | - 90ad0b8: Fix stream methods return types
 52 | - 4d8f501: Retry on server errors
 53 | 
 54 | ## 0.6.2
 55 | 
 56 | ### Patch Changes
 57 | 
 58 | - 401268b: Support `take` and `skip` params in `ErgoGraphQLProvider#stream*()` methods
 59 | 
 60 | ## 0.6.1
 61 | 
 62 | ### Patch Changes
 63 | 
 64 | - 208ac8e: Fix `Header#votes` encoding
 65 | - a3d2a62: Export `BlockChainProviders` types
 66 | - 506dfc4: [`ErgoGraphQLProvider`] Query Addresses/ErgoTrees by chunks of 20
 67 | - 6245bc9: Export `request` and `createGqlOperation` utility functions
 68 | - Updated dependencies [ece573c]
 69 |   - @fleet-sdk/core@0.6.1
 70 | 
 71 | ## 0.6.0
 72 | 
 73 | ### Minor Changes
 74 | 
 75 | - 6ef2c1b: Add custom `BigInt` mapping support
 76 | - 9cdf4dd: Add transaction fetching
 77 | 
 78 | ### Patch Changes
 79 | 
 80 | - 62b881b: Add exponential delay retrying strategy
 81 | - 9ed3499: Add GraphQL operation URL override
 82 | 
 83 | ## 0.5.0
 84 | 
 85 | ### Patch Changes
 86 | 
 87 | - Updated dependencies [8f14d37]
 88 |   - @fleet-sdk/core@0.5.0
 89 | 
 90 | ## 0.4.1
 91 | 
 92 | ### Patch Changes
 93 | 
 94 | - Updated dependencies [28e3467]
 95 |   - @fleet-sdk/common@0.4.1
 96 |   - @fleet-sdk/core@0.4.1
 97 | 
 98 | ## 0.4.0
 99 | 
100 | ### Patch Changes
101 | 
102 | - @fleet-sdk/core@0.4.0
103 | 
104 | ## 0.3.4
105 | 
106 | ### Patch Changes
107 | 
108 | - 9f02ca0: Fix ESM and CJS modules export
109 | - Updated dependencies [0fbe19f]
110 | - Updated dependencies [9f02ca0]
111 |   - @fleet-sdk/core@0.3.4
112 |   - @fleet-sdk/common@0.3.4
113 | 
114 | ## 0.3.3
115 | 
116 | ### Patch Changes
117 | 
118 | - 227c888: Fix type exporting
119 | 
120 | ## 0.3.2
121 | 
122 | ### Patch Changes
123 | 
124 | - 1d6e259: Introduce `@fleet-sdk/blockchain-providers` package with `ErgoGraphQLProvider`
125 | - Updated dependencies [1d6e259]
126 | - Updated dependencies [1d6e259]
127 | - Updated dependencies [1d6e259]
128 |   - @fleet-sdk/common@0.3.2
129 |   - @fleet-sdk/core@0.3.2
130 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2023 Nautilus Team
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/README.md:
--------------------------------------------------------------------------------
 1 | # @fleet-sdk/blockchain-providers [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/blockchain-providers)](https://www.npmjs.com/package/@fleet-sdk/blockchain-providers)
 2 | 
 3 | Ergo Blockchain data providers.
 4 | 
 5 | ## Build
 6 | 
 7 | ```sh
 8 | pnpm --filter blockchain-providers build
 9 | ```
10 | 
11 | ## Test
12 | 
13 | ```sh
14 | pnpm test:unit blockchain-providers
15 | ```
16 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/blockchain-providers",
 3 |   "version": "0.8.2",
 4 |   "description": "Blockchain data providers",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "crypto"
31 |   ],
32 |   "scripts": {
33 |     "build": "tsup --config ../../tsup.config.ts"
34 |   },
35 |   "engines": {
36 |     "node": ">=18"
37 |   },
38 |   "dependencies": {
39 |     "@fleet-sdk/common": "workspace:^",
40 |     "@fleet-sdk/core": "workspace:^"
41 |   },
42 |   "files": [
43 |     "src",
44 |     "dist",
45 |     "!**/*.spec.*",
46 |     "!**/*.json",
47 |     "!tests",
48 |     "CHANGELOG.md",
49 |     "LICENSE",
50 |     "README.md"
51 |   ],
52 |   "devDependencies": {
53 |     "@ergo-graphql/types": "^0.5.1"
54 |   }
55 | }
56 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/src/ergo-graphql/queries.ts:
--------------------------------------------------------------------------------
 1 | const B = [
 2 |   "$boxIds: [String!] $ergoTrees: [String!] $ergoTreeTemplateHash: String $tokenId: String $skip: Int $take: Int",
 3 |   "boxIds: $boxIds ergoTrees: $ergoTrees ergoTreeTemplateHash: $ergoTreeTemplateHash tokenId: $tokenId skip: $skip take: $take",
 4 |   "boxId transactionId index value creationHeight ergoTree assets { tokenId amount } additionalRegisters"
 5 | ];
 6 | 
 7 | export const CONF_BOXES_QUERY = `query boxes($spent: Boolean! ${B[0]}) { boxes(spent: $spent ${B[1]}) { ${B[2]} beingSpent } }`;
 8 | export const UNCONF_BOXES_QUERY = `query boxes(${B[0]}) { mempool { boxes(${B[1]}) { ${B[2]} beingSpent } } }`;
 9 | export const ALL_BOXES_QUERY = `query boxes($spent: Boolean! ${B[0]}) { boxes(spent: $spent ${B[1]}) { ${B[2]} beingSpent } mempool { boxes(${B[1]}) { ${B[2]} beingSpent } } }`;
10 | 
11 | export const HEADERS_QUERY =
12 |   "query blockHeaders($take: Int) { blockHeaders(take: $take) {headerId timestamp version adProofsRoot stateRoot transactionsRoot nBits extensionHash powSolutions height difficulty parentId votes } }";
13 | export const CHECK_TX_MUTATION =
14 |   "mutation checkTransaction($signedTransaction: SignedTransaction!) { checkTransaction(signedTransaction: $signedTransaction) }";
15 | export const SEND_TX_MUTATION =
16 |   "mutation submitTransaction($signedTransaction: SignedTransaction!) { submitTransaction(signedTransaction: $signedTransaction) }";
17 | 
18 | const T = [
19 |   "$addresses: [String!], $transactionIds: [String!], $skip: Int, $take: Int",
20 |   "addresses: $addresses, transactionIds: $transactionIds, skip: $skip, take: $take",
21 |   `transactionId timestamp inputs { proofBytes extension index box { ${B[2]} } } dataInputs { boxId }`
22 | ];
23 | export const CONF_TX_QUERY = `query confirmedTransactions(${T[0]}  $onlyRelevantOutputs: Boolean) { transactions(${T[1]}) { ${T[2]} outputs(relevantOnly: $onlyRelevantOutputs) { ${B[2]} } inclusionHeight headerId index } }`;
24 | export const UNCONF_TX_QUERY = `query unconfirmedTransactions(${T[0]}) { mempool { transactions(${T[1]}) { ${T[2]} outputs { ${B[2]} } } } }`;
25 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./ergo-graphql/ergoGraphQLProvider";
2 | export * from "./types/blockchainProvider";
3 | export * from "./utils/networking";
4 | export * from "./utils/graphql";
5 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/src/utils/_tests.ts:
--------------------------------------------------------------------------------
1 | export const resolveString = (data: string) =>
2 |   ({
3 |     text: () => new Promise((resolve) => resolve(data))
4 |   }) as unknown as Response;
5 | 
6 | export const resolveData = (data: unknown) => resolveString(JSON.stringify(data));
7 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/src/utils/graphql.test-d.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expectTypeOf, it } from "vitest";
 2 | import {
 3 |   createGqlOperation,
 4 |   type GraphQLOperation,
 5 |   type GraphQLResponse,
 6 |   type GraphQLSuccessResponse,
 7 |   type GraphQLVariables
 8 | } from "./graphql";
 9 | 
10 | describe("createGqlOperation() types", () => {
11 |   const query = "query test { state { height } }";
12 |   const url = "https://gql.example.com/";
13 | 
14 |   it("Should infer the correct type when throwOnNonNetworkErrors is set to true", () => {
15 |     const throwable = createGqlOperation(query, {
16 |       throwOnNonNetworkErrors: true,
17 |       url
18 |     });
19 |     expectTypeOf(throwable).toMatchTypeOf<
20 |       GraphQLOperation<GraphQLSuccessResponse, GraphQLVariables>
21 |     >();
22 | 
23 |     const notThrowable = createGqlOperation(query, {
24 |       throwOnNonNetworkErrors: false,
25 |       url
26 |     });
27 |     expectTypeOf(notThrowable).toMatchTypeOf<
28 |       GraphQLOperation<GraphQLResponse, GraphQLVariables>
29 |     >();
30 |   });
31 | });
32 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/src/utils/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./graphql";
2 | export * from "./_tests";
3 | 


--------------------------------------------------------------------------------
/packages/blockchain-providers/src/utils/networking.ts:
--------------------------------------------------------------------------------
 1 | import { some } from "@fleet-sdk/common";
 2 | 
 3 | export interface ParserLike {
 4 |   parse<T>(text: string): T;
 5 |   stringify<T>(value: T): string;
 6 | }
 7 | 
 8 | export type Route = { base: string; path: string; query?: Record<string, unknown> };
 9 | export type URLLike = string | Route;
10 | export type FallbackRetryOptions = { fallbacks?: URLLike[] } & RetryOptions;
11 | 
12 | export type FetchOptions = {
13 |   parser?: ParserLike;
14 |   base?: string;
15 |   query?: Record<string, unknown>;
16 |   retry?: FallbackRetryOptions;
17 |   httpOptions?: RequestInit;
18 | };
19 | 
20 | // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
21 | const RETRY_STATUS_CODES = new Set([
22 |   408, // Request Timeout
23 |   409, // Conflict
24 |   425, // Too Early (Experimental)
25 |   429, // Too Many Requests
26 |   500, // Internal Server Error
27 |   502, // Bad Gateway
28 |   503, // Service Unavailable
29 |   504 // Gateway Timeout
30 | ]);
31 | 
32 | export async function request<T>(path: string, opt?: Partial<FetchOptions>): Promise<T> {
33 |   const url = buildURL(path, opt?.query, opt?.base);
34 | 
35 |   let response: Response;
36 |   if (opt?.retry) {
37 |     const routes = some(opt.retry.fallbacks) ? [url, ...opt.retry.fallbacks] : [url];
38 |     const attempts = opt.retry.attempts;
39 |     response = await exponentialRetry(async (r) => {
40 |       const response = await fetch(resolveUrl(routes, attempts - r), opt.httpOptions);
41 |       if (RETRY_STATUS_CODES.has(response.status)) throw new Error(response.statusText);
42 | 
43 |       return response;
44 |     }, opt.retry);
45 |   } else {
46 |     response = await fetch(url, opt?.httpOptions);
47 |   }
48 | 
49 |   return (opt?.parser || JSON).parse(await response.text());
50 | }
51 | 
52 | function resolveUrl(routes: URLLike[], attempt: number) {
53 |   const route = routes[attempt % routes.length];
54 |   return typeof route === "string"
55 |     ? route
56 |     : buildURL(route.path, route.query, route.base).toString();
57 | }
58 | 
59 | function buildURL(path: string, query?: Record<string, unknown>, base?: string) {
60 |   if (!base && !query) return path;
61 | 
62 |   const url = new URL(path, base);
63 |   if (some(query)) {
64 |     for (const key in query) url.searchParams.append(key, String(query[key]));
65 |   }
66 | 
67 |   return url.toString();
68 | }
69 | 
70 | export type RetryOptions = {
71 |   attempts: number;
72 |   delay: number;
73 | };
74 | 
75 | /**
76 |  * Retries an asynchronous operation a specified number of times with a delay
77 |  * growing exponentially between each attempt.
78 |  * @param operation - The asynchronous operation to retry.
79 |  * @param options - The retry options.
80 |  * @returns A promise that resolves to the result of the operation, or undefined
81 |  * if all attempts fail.
82 |  */
83 | export async function exponentialRetry<T>(
84 |   operation: (remainingAttempts: number) => Promise<T>,
85 |   { attempts, delay }: RetryOptions
86 | ): Promise<T> {
87 |   try {
88 |     return await operation(attempts);
89 |   } catch (e) {
90 |     if (attempts > 0) {
91 |       await new Promise((resolve) => setTimeout(resolve, delay));
92 |       return exponentialRetry(operation, { attempts: attempts - 1, delay: delay * 2 });
93 |     }
94 | 
95 |     throw e;
96 |   }
97 | }
98 | 


--------------------------------------------------------------------------------
/packages/common/CHANGELOG.md:
--------------------------------------------------------------------------------
  1 | # @fleet-sdk/common
  2 | 
  3 | ## 0.8.0
  4 | 
  5 | ### Patch Changes
  6 | 
  7 | - 36adc61: Fix `chunk` when passing an empty input array.
  8 | 
  9 | ## 0.6.4
 10 | 
 11 | ### Patch Changes
 12 | 
 13 | - 504974e: Fix `utxoDiff` miscalculation when tokens are present in subtrahend but not in minuend
 14 | 
 15 | ## 0.4.1
 16 | 
 17 | ### Patch Changes
 18 | 
 19 | - 28e3467: Fix `ensureDefaults()` behavior with `undefined` fields
 20 | 
 21 | ## 0.3.4
 22 | 
 23 | ### Patch Changes
 24 | 
 25 | - 9f02ca0: Fix ESM and CJS modules export
 26 | 
 27 | ## 0.3.2
 28 | 
 29 | ### Patch Changes
 30 | 
 31 | - 1d6e259: Add API TSDocs
 32 | - 1d6e259: Fix `ensureDefaults` function types
 33 | 
 34 | ## 0.2.3
 35 | 
 36 | ### Patch Changes
 37 | 
 38 | - 1e0edd4: Fix missing `types` export in `package.json`
 39 | 
 40 | ## 0.2.2
 41 | 
 42 | ### Patch Changes
 43 | 
 44 | - 9cbd414: Add `Block` and `BlockHeader` types.
 45 | 
 46 | ## 0.2.1
 47 | 
 48 | ### Patch Changes
 49 | 
 50 | - edf2830: Fix module exporting.
 51 | 
 52 | ## 0.2.0
 53 | 
 54 | ### Minor Changes
 55 | 
 56 | - 5a79c57: Add `concatBytes()` function.
 57 | - a491ab9: Add `ensureDefaults()` function.
 58 | - 3236dd8: Add new assertion functions:
 59 |   - `assertTypeOf()` - uses `typeof` to check for JavaScript type primitives;
 60 |   - `assertInstanceOf()` - uses `instanceof` to check for object instances.
 61 | - 9bd393b: Add `depthOf()` function.
 62 | 
 63 | ## 0.1.3
 64 | 
 65 | ### Patch Changes
 66 | 
 67 | - 92d8477: Move `Collection` model from core to common package.
 68 | - 280308a: Add `hasKey()` function.
 69 | - e9f4d74: Add `ensureUTxOBigInt()` function.
 70 | - 40a23b2: Add `percent()` function.
 71 | - be6364f: Refactored and added new assertion functions.
 72 | - d59dc22: Fix `first()` function when the first item is equal to zero.
 73 | - 452f97d: Add `min()` and `max()` utility functions.
 74 | 
 75 | ## 0.1.2
 76 | 
 77 | ### Patch Changes
 78 | 
 79 | - 72a8b4f: Fix NPM provenance
 80 | 
 81 | ## 0.1.1
 82 | 
 83 | ### Patch Changes
 84 | 
 85 | - ca22fab: Fix changesets
 86 | 
 87 | ## 0.1.0
 88 | 
 89 | ### Patch Changes
 90 | 
 91 | - 4759a8f: Add NPM provenance
 92 | - b67472a: Add `Box<T, R>` type improvements
 93 | 
 94 | ## 0.1.0-alpha.32
 95 | 
 96 | ### Patch Changes
 97 | 
 98 | - 4759a8f: Add NPM provenance
 99 | 
100 | ## 0.1.0-alpha.31
101 | 
102 | ### Patch Changes
103 | 
104 | - b67472a: Add `Box<T, R>` type improvements
105 | 


--------------------------------------------------------------------------------
/packages/common/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/common/README.md:
--------------------------------------------------------------------------------
1 | # @fleet-sdk/common [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/common)](https://www.npmjs.com/package/@fleet-sdk/common)
2 | 
3 | Internal utility functions, constants and types shared across @fleet-sdk packages.
4 | 


--------------------------------------------------------------------------------
/packages/common/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/common",
 3 |   "version": "0.8.0",
 4 |   "description": "Internal utility functions, constants and types shared across @fleet-sdk packages.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain"
30 |   ],
31 |   "scripts": {
32 |     "build": "tsup --config ../../tsup.config.ts"
33 |   },
34 |   "engines": {
35 |     "node": ">=18"
36 |   },
37 |   "files": [
38 |     "dist",
39 |     "!**/*.spec.*",
40 |     "!**/*.json",
41 |     "!tests",
42 |     "CHANGELOG.md",
43 |     "LICENSE",
44 |     "README.md"
45 |   ]
46 | }
47 | 


--------------------------------------------------------------------------------
/packages/common/src/error.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { BlockchainProviderError, FleetError, NotSupportedError } from "./error";
 3 | 
 4 | describe("Errors", () => {
 5 |   it("Should construct errors", () => {
 6 |     const errorMsg = "error smoke test";
 7 | 
 8 |     expect(new FleetError().name).to.be.equal("FleetError");
 9 |     expect(new NotSupportedError().name).to.be.equal("NotSupportedError");
10 |     expect(new BlockchainProviderError().name).to.be.equal("BlockchainProviderError");
11 | 
12 |     expect(() => {
13 |       throw new FleetError(errorMsg);
14 |     }).to.throw(FleetError, errorMsg);
15 | 
16 |     expect(() => {
17 |       throw new NotSupportedError(errorMsg);
18 |     }).to.throw(NotSupportedError, errorMsg);
19 |   });
20 | });
21 | 


--------------------------------------------------------------------------------
/packages/common/src/error.ts:
--------------------------------------------------------------------------------
 1 | export class FleetError extends Error {
 2 |   constructor(message?: string, options?: ErrorOptions) {
 3 |     super(message, options);
 4 | 
 5 |     Object.setPrototypeOf(this, new.target.prototype);
 6 |     this.name = new.target.name;
 7 |   }
 8 | }
 9 | 
10 | export class NotSupportedError extends FleetError {}
11 | 
12 | export class BlockchainProviderError extends FleetError {}
13 | 


--------------------------------------------------------------------------------
/packages/common/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./utils";
2 | export * from "./types";
3 | export * from "./models/collection";
4 | export * from "./error";
5 | 


--------------------------------------------------------------------------------
/packages/common/src/types/block.ts:
--------------------------------------------------------------------------------
 1 | import type { HexString } from "./common";
 2 | import type { SignedTransaction } from "./transactions";
 3 | 
 4 | export type PoWSolution = {
 5 |   pk: HexString;
 6 |   w: HexString;
 7 |   n: string;
 8 |   d: number;
 9 | };
10 | 
11 | export type BlockHeaderId = string;
12 | 
13 | export type BlockTransactions = {
14 |   headerId: BlockHeaderId;
15 |   transactions: SignedTransaction[];
16 | };
17 | 
18 | export type BlockHeader = {
19 |   id: BlockHeaderId;
20 |   timestamp: number;
21 |   version: number;
22 |   adProofsRoot: HexString;
23 |   stateRoot: HexString;
24 |   transactionsRoot: HexString;
25 |   nBits: number;
26 |   extensionHash: HexString;
27 |   powSolutions: PoWSolution;
28 |   height: number;
29 |   difficulty: string;
30 |   parentId: BlockHeaderId;
31 |   votes: string;
32 |   size?: number;
33 |   extensionId?: HexString;
34 |   transactionsId?: HexString;
35 |   adProofsId?: HexString;
36 | };
37 | 
38 | export type Block = {
39 |   header: BlockHeader;
40 |   blockTransactions: BlockTransactions;
41 |   adProofs: unknown; // TODO
42 |   extension: unknown; // TODO
43 |   size: number;
44 | };
45 | 


--------------------------------------------------------------------------------
/packages/common/src/types/boxes.ts:
--------------------------------------------------------------------------------
 1 | import type { Amount, ErgoTreeHex } from "./common";
 2 | import type { NonMandatoryRegisters } from "./registers";
 3 | import type { TokenAmount } from "./token";
 4 | import type { TransactionId } from "./transactions";
 5 | 
 6 | export type BoxId = string;
 7 | 
 8 | type BoxBaseType<T extends Amount, R extends NonMandatoryRegisters> = {
 9 |   ergoTree: ErgoTreeHex;
10 |   creationHeight: number;
11 |   value: T;
12 |   assets: TokenAmount<T>[];
13 |   additionalRegisters: R;
14 | };
15 | 
16 | export type BoxCandidate<
17 |   T extends Amount,
18 |   R extends NonMandatoryRegisters = NonMandatoryRegisters
19 | > = BoxBaseType<T, R> & {
20 |   boxId?: BoxId;
21 | };
22 | 
23 | export type Box<
24 |   T extends Amount = Amount,
25 |   R extends NonMandatoryRegisters = NonMandatoryRegisters
26 | > = BoxBaseType<T, R> & {
27 |   boxId: BoxId;
28 |   transactionId: TransactionId;
29 |   index: number;
30 | };
31 | 


--------------------------------------------------------------------------------
/packages/common/src/types/common.ts:
--------------------------------------------------------------------------------
 1 | export type HexString = string;
 2 | export type ErgoTreeHex = string;
 3 | export type Base58String = string;
 4 | export type Amount = string | bigint;
 5 | 
 6 | export type OneOrMore<T> = T | T[];
 7 | 
 8 | export type SortingSelector<T> = (item: T) => string | number | bigint;
 9 | export type SortingDirection = "asc" | "desc";
10 | 
11 | export type FilterPredicate<T> = (item: T) => boolean;
12 | 
13 | export type PlainObjectType = "minimal" | "EIP-12";
14 | 


--------------------------------------------------------------------------------
/packages/common/src/types/enums.ts:
--------------------------------------------------------------------------------
 1 | export type EnumConst<T extends object> = T[keyof T];
 2 | 
 3 | export enum Network {
 4 |   Mainnet = 0x00,
 5 |   Testnet = 0x10
 6 | }
 7 | 
 8 | export enum AddressType {
 9 |   P2PK = 1,
10 |   P2SH = 2,
11 |   P2S = 3,
12 |   ADH = 4
13 | }
14 | 
15 | export const ergoTreeHeaderFlags = {
16 |   sizeInclusion: 0x08,
17 |   constantSegregation: 0x10
18 | } as const;
19 | 
20 | export type ErgoTreeHeaderFlag = EnumConst<typeof ergoTreeHeaderFlags>;
21 | 


--------------------------------------------------------------------------------
/packages/common/src/types/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./boxes";
2 | export * from "./inputs";
3 | export * from "./common";
4 | export * from "./registers";
5 | export * from "./token";
6 | export * from "./transactions";
7 | export * from "./block";
8 | export * from "./enums";
9 | 


--------------------------------------------------------------------------------
/packages/common/src/types/inputs.ts:
--------------------------------------------------------------------------------
 1 | import type { BoxId } from "./boxes";
 2 | import type { ErgoTreeHex, HexString } from "./common";
 3 | import type { NonMandatoryRegisters } from "./registers";
 4 | import type { TokenAmount } from "./token";
 5 | import type { TransactionId } from "./transactions";
 6 | 
 7 | export type ContextExtension<T = HexString> = { [key: number]: T | undefined };
 8 | 
 9 | export type ProverResult = {
10 |   readonly proofBytes: HexString;
11 |   readonly extension: ContextExtension;
12 | };
13 | 
14 | export type SignedInput = {
15 |   readonly boxId: BoxId;
16 |   readonly spendingProof: ProverResult;
17 | };
18 | 
19 | export type UnsignedInput = {
20 |   boxId: BoxId;
21 |   extension: ContextExtension;
22 | };
23 | 
24 | export type EIP12UnsignedInput = UnsignedInput & {
25 |   transactionId: TransactionId;
26 |   index: number;
27 |   ergoTree: ErgoTreeHex;
28 |   creationHeight: number;
29 |   value: string;
30 |   assets: TokenAmount<string>[];
31 |   additionalRegisters: NonMandatoryRegisters;
32 | };
33 | 
34 | export type EIP12UnsignedDataInput = {
35 |   boxId: BoxId;
36 |   transactionId: TransactionId;
37 |   index: number;
38 |   ergoTree: ErgoTreeHex;
39 |   creationHeight: number;
40 |   value: string;
41 |   assets: TokenAmount<string>[];
42 |   additionalRegisters: NonMandatoryRegisters;
43 | };
44 | 
45 | export type DataInput = {
46 |   boxId: BoxId;
47 | };
48 | 


--------------------------------------------------------------------------------
/packages/common/src/types/registers.ts:
--------------------------------------------------------------------------------
 1 | import type { HexString } from "./common";
 2 | 
 3 | export type NonMandatoryRegisters<T = HexString> = {
 4 |   R4?: T;
 5 |   R5?: T;
 6 |   R6?: T;
 7 |   R7?: T;
 8 |   R8?: T;
 9 |   R9?: T;
10 | };
11 | 


--------------------------------------------------------------------------------
/packages/common/src/types/token.ts:
--------------------------------------------------------------------------------
 1 | export type TokenId = string;
 2 | 
 3 | type TokenBase<AmountType> = {
 4 |   amount: AmountType;
 5 | };
 6 | 
 7 | export type TokenAmount<AmountType> = TokenBase<AmountType> & {
 8 |   tokenId: TokenId;
 9 | };
10 | 
11 | export type NewToken<AmountType> = TokenBase<AmountType> & {
12 |   tokenId?: TokenId;
13 |   name?: string;
14 |   decimals?: number;
15 |   description?: string;
16 | };
17 | 
18 | export type TokenTargetAmount<AmountType> = {
19 |   tokenId: TokenId;
20 |   amount?: AmountType;
21 | };
22 | 


--------------------------------------------------------------------------------
/packages/common/src/types/transactions.ts:
--------------------------------------------------------------------------------
 1 | import type { Box, BoxCandidate } from "./boxes";
 2 | import type { Amount } from "./common";
 3 | import type {
 4 |   DataInput,
 5 |   EIP12UnsignedDataInput,
 6 |   EIP12UnsignedInput,
 7 |   SignedInput,
 8 |   UnsignedInput
 9 | } from "./inputs";
10 | 
11 | export type TransactionId = string;
12 | 
13 | export type UnsignedTransaction = {
14 |   id?: TransactionId;
15 |   inputs: UnsignedInput[];
16 |   dataInputs: DataInput[];
17 |   outputs: BoxCandidate<Amount>[];
18 | };
19 | 
20 | export type EIP12UnsignedTransaction = {
21 |   id?: TransactionId;
22 |   inputs: EIP12UnsignedInput[];
23 |   dataInputs: EIP12UnsignedDataInput[];
24 |   outputs: BoxCandidate<string>[];
25 | };
26 | 
27 | export type SignedTransaction = {
28 |   readonly id: TransactionId;
29 |   readonly inputs: SignedInput[];
30 |   readonly dataInputs: DataInput[];
31 |   readonly outputs: Box<string>[];
32 | };
33 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/assertions.ts:
--------------------------------------------------------------------------------
 1 | export type ErrorMessage = string | Error | (() => string);
 2 | 
 3 | // biome-ignore lint/complexity/noBannedTypes: <explanation>
 4 | type Constructable = Function;
 5 | 
 6 | type JSPrimitive =
 7 |   | "string"
 8 |   | "number"
 9 |   | "bigint"
10 |   | "boolean"
11 |   | "symbol"
12 |   | "undefined"
13 |   | "object"
14 |   | "function";
15 | 
16 | export function assert(condition: boolean, error: ErrorMessage): asserts condition {
17 |   if (condition) return;
18 | 
19 |   let err: Error | undefined = undefined;
20 |   switch (typeof error) {
21 |     case "string":
22 |       err = new Error(error);
23 |       break;
24 |     case "function":
25 |       err = new Error(error());
26 |       break;
27 |     default:
28 |       err = error;
29 |   }
30 | 
31 |   throw err;
32 | }
33 | 
34 | export function assertTypeOf<T>(obj: T, expected: JSPrimitive): asserts obj {
35 |   const type = typeof obj;
36 | 
37 |   if (type !== expected) {
38 |     throw new Error(`Expected an object of type '${expected}', got '${type}'.`);
39 |   }
40 | }
41 | 
42 | function getTypeName(value: unknown): string {
43 |   if (value === null) return "null";
44 |   const type = typeof value;
45 | 
46 |   return type === "object" || type === "function"
47 |     ? Object.prototype.toString.call(value).slice(8, -1)
48 |     : type;
49 | }
50 | 
51 | export function assertInstanceOf<T>(obj: T, expected: Constructable): asserts obj {
52 |   const condition = obj instanceof expected;
53 | 
54 |   if (!condition) {
55 |     throw new Error(
56 |       `Expected an instance of '${expected.name}', got '${getTypeName(obj)}'.`
57 |     );
58 |   }
59 | }
60 | 
61 | export function isEmpty<T>(target: T | null | undefined): target is undefined | null {
62 |   if (!target) return true;
63 | 
64 |   return Array.isArray(target) ? target.length === 0 : Object.keys(target).length === 0;
65 | }
66 | 
67 | export function some<T>(target: T | null | undefined): target is T {
68 |   return !isEmpty(target);
69 | }
70 | 
71 | export function isTruthy<T>(value?: T): value is NonNullable<T> {
72 |   return !!value;
73 | }
74 | 
75 | export function isFalsy<T>(value?: T): value is undefined {
76 |   return !value;
77 | }
78 | 
79 | export function isUndefined(v: unknown): v is undefined {
80 |   return v === undefined || v === null || Number.isNaN(v);
81 | }
82 | 
83 | export function isDefined<T>(v: T | undefined): v is T {
84 |   return !isUndefined(v);
85 | }
86 | 
87 | export function hasKey(o: unknown, key: PropertyKey): boolean {
88 |   return Object.prototype.hasOwnProperty.call(o, key);
89 | }
90 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/bytes.bench.ts:
--------------------------------------------------------------------------------
 1 | import { bench, describe } from "vitest";
 2 | import { isHex } from "./bytes";
 3 | 
 4 | const HEX_PATTERN = /^[0-9A-Fa-f]+$/s;
 5 | function isHexRegex(value?: string) {
 6 |   if (!value || value.length % 2) return false;
 7 |   return HEX_PATTERN.test(value);
 8 | }
 9 | 
10 | const HEX_CHARSET = new Set("0123456789abcdefABCDEF");
11 | function isHexChar(value: string) {
12 |   if (!value || value.length % 2) return false;
13 | 
14 |   const valueSet = new Set(value);
15 |   for (const c of valueSet) {
16 |     if (!HEX_CHARSET.has(c)) return false;
17 |   }
18 | 
19 |   return true;
20 | }
21 | 
22 | describe("Hex string checking", () => {
23 |   const validHex =
24 |     "0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7";
25 |   const invalidHex =
26 |     "0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7tt";
27 | 
28 |   bench("Using charset", () => {
29 |     isHexChar(validHex);
30 |     isHexChar(invalidHex);
31 |   });
32 | 
33 |   bench("Using regex", () => {
34 |     isHexRegex(validHex);
35 |     isHexRegex(invalidHex);
36 |   });
37 | 
38 |   bench("Using number constructor", () => {
39 |     isHex(validHex);
40 |     isHex(invalidHex);
41 |   });
42 | });
43 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/bytes.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { byteSizeOf, concatBytes, isHex } from "./bytes";
 3 | 
 4 | const ui8 = (bytes: number[]) => Uint8Array.from(bytes);
 5 | 
 6 | describe("Bytes concatenation", () => {
 7 |   it("Should concat bytes", () => {
 8 |     expect(concatBytes(ui8([0xde, 0xad]), ui8([0xbe, 0xef]))).to.be.deep.equal(
 9 |       ui8([0xde, 0xad, 0xbe, 0xef])
10 |     );
11 | 
12 |     expect(concatBytes(ui8([0xde, 0xad, 0xbe, 0xef]), ui8([]))).to.be.deep.equal(
13 |       ui8([0xde, 0xad, 0xbe, 0xef])
14 |     );
15 | 
16 |     expect(concatBytes(ui8([]), ui8([0xde, 0xad, 0xbe, 0xef]))).to.be.deep.equal(
17 |       ui8([0xde, 0xad, 0xbe, 0xef])
18 |     );
19 |   });
20 | 
21 |   it("Should fail with invalid inputs", () => {
22 |     expect(() => concatBytes({} as unknown as Uint8Array, ui8([]))).to.throw(
23 |       "Expected an instance of 'Uint8Array', got 'Object'."
24 |     );
25 |   });
26 | });
27 | 
28 | describe("isHex() test", () => {
29 |   it("Should pass with VALID hex strings", () => {
30 |     expect(
31 |       isHex("0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7")
32 |     ).toBeTruthy();
33 | 
34 |     expect(isHex("0xdeadbeef")).toBeTruthy();
35 |   });
36 | 
37 |   it("Should fail with INVALID hex strings", () => {
38 |     expect(isHex("this is a non hex string")).toBeFalsy();
39 |     expect(
40 |       isHex("n 0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7")
41 |     ).toBeFalsy();
42 | 
43 |     expect(isHex("deadbee")).toBeFalsy();
44 |   });
45 | 
46 |   it("Should fail with falsy arguments", () => {
47 |     expect(isHex("")).toBeFalsy();
48 |     expect(isHex(undefined)).toBeFalsy();
49 |   });
50 | 
51 |   it("Should return the byte size of a hex string", () => {
52 |     expect(
53 |       byteSizeOf(
54 |         "0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7"
55 |       )
56 |     ).toBe(36);
57 |   });
58 | });
59 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/bytes.ts:
--------------------------------------------------------------------------------
 1 | import { assertInstanceOf } from ".";
 2 | 
 3 | export function concatBytes(...arrays: Uint8Array[]): Uint8Array {
 4 |   const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
 5 | 
 6 |   let pad = 0;
 7 |   for (const bytes of arrays) {
 8 |     assertInstanceOf(bytes, Uint8Array);
 9 | 
10 |     r.set(bytes, pad);
11 |     pad += bytes.length;
12 |   }
13 | 
14 |   return r;
15 | }
16 | 
17 | export function isHex(value?: string) {
18 |   if (!value || value.length % 2) return false;
19 |   return !Number.isNaN(Number(value.startsWith("0x") ? value : `0x${value}`));
20 | }
21 | 
22 | /**
23 |  * Get hex string size in bytes
24 |  * @param hex
25 |  * @returns the byte size if the hex string
26 |  */
27 | export function byteSizeOf(hex: string): number {
28 |   return hex.length / 2;
29 | }
30 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./array";
2 | export * from "./bigInt";
3 | export * from "./utxo";
4 | export * from "./object";
5 | export * from "./assertions";
6 | export * from "./bytes";
7 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/object.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { clearUndefined, ensureDefaults } from "./object";
 3 | 
 4 | describe("Remove undefined fields", () => {
 5 |   it("Should remove", () => {
 6 |     expect(
 7 |       clearUndefined({
 8 |         propOne: 1,
 9 |         propTwo: undefined,
10 |         propThree: "test",
11 |         nullProp: null
12 |       })
13 |     ).toEqual({ propOne: 1, propThree: "test" });
14 |   });
15 | });
16 | 
17 | describe("Ensure defaults", () => {
18 |   it("Should supplied defaults", () => {
19 |     const defaults = {
20 |       a: 1,
21 |       b: 2,
22 |       c: 3,
23 |       y: undefined as number | undefined,
24 |       z: 0
25 |     };
26 | 
27 |     expect(ensureDefaults(undefined, defaults)).to.be.equal(defaults);
28 |     expect(ensureDefaults({}, defaults)).to.be.equal(defaults);
29 |     expect(ensureDefaults([] as unknown as object, defaults)).to.be.equal(defaults);
30 | 
31 |     expect(ensureDefaults({ a: 5, t: 1 }, defaults)).to.be.deep.equal({
32 |       a: 5, // opt
33 |       b: 2, // defaults
34 |       c: 3, // defaults
35 |       y: undefined, // defaults
36 |       t: 1, // opt,
37 |       z: 0 // defaults
38 |     });
39 | 
40 |     expect(ensureDefaults({ a: 52, b: 0, y: 100 }, defaults)).to.be.deep.equal({
41 |       a: 52, // opt
42 |       b: 0, // defaults
43 |       c: 3, // defaults
44 |       y: 100, // opt,
45 |       z: 0 // defaults
46 |     });
47 |   });
48 | 
49 |   it("Should replace undefined keys by default", () => {
50 |     const defaults = { a: 1, b: 2 };
51 | 
52 |     expect(ensureDefaults({ a: 5, b: undefined }, defaults)).to.be.deep.equal({
53 |       a: 5,
54 |       b: 2 // it must replace undefined
55 |     });
56 |   });
57 | 
58 |   it("Should optionally replace undefined keys", () => {
59 |     const defaults = { a: 1, b: 2 };
60 | 
61 |     expect(
62 |       ensureDefaults({ a: 5, b: undefined }, defaults, {
63 |         keepUndefinedKeys: true
64 |       })
65 |     ).to.be.deep.equal({
66 |       a: 5,
67 |       b: undefined // it must keep undefined
68 |     });
69 |   });
70 | });
71 | 


--------------------------------------------------------------------------------
/packages/common/src/utils/object.ts:
--------------------------------------------------------------------------------
 1 | import { isEmpty, isUndefined } from "./assertions";
 2 | 
 3 | /**
 4 |  * Remove undefined values from an object
 5 |  * @param value
 6 |  *
 7 |  * @example
 8 |  * ```
 9 |  * const obj = { a: 1, b: undefined };
10 |  * const result = clearUndefined(obj);
11 |  * console.log(result); // { a: 1 }
12 |  * ```
13 |  */
14 | export function clearUndefined(value: Record<string, unknown>) {
15 |   const result: Record<string, unknown> = {};
16 |   for (const key in value) {
17 |     const val = value[key];
18 |     if (!isUndefined(val)) {
19 |       result[key] = val;
20 |     }
21 |   }
22 | 
23 |   return result;
24 | }
25 | 
26 | export type EnsureDefaultsOptions = { keepUndefinedKeys: boolean };
27 | 
28 | /**
29 |  * Ensure that the options object has all the default values
30 |  * @param partial
31 |  * @param defaults
32 |  *
33 |  * @example
34 |  * ```
35 |  * const options = { a: 1 };
36 |  * const defaults = { a: 2, b: 3 };
37 |  * const result = ensureDefaults(options, defaults);
38 |  * console.log(result); // { a: 1, b: 3 }
39 |  * ```
40 |  */
41 | export function ensureDefaults<T extends object, R extends object>(
42 |   partial: T | undefined,
43 |   defaults: R,
44 |   options?: EnsureDefaultsOptions
45 | ): R & T {
46 |   if (isEmpty(partial)) return defaults as R & T;
47 |   if (options?.keepUndefinedKeys) return { ...defaults, ...partial };
48 | 
49 |   const merged = { ...defaults, ...partial } as Record<string, unknown>;
50 |   for (const key in merged) {
51 |     merged[key] = partial[key as keyof T] ?? defaults[key as keyof R];
52 |   }
53 | 
54 |   return merged as R & T;
55 | }
56 | 


--------------------------------------------------------------------------------
/packages/compiler/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 Fleet SDK
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/compiler/README.md:
--------------------------------------------------------------------------------
 1 | # @fleet-sdk/compiler [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/compiler)](https://www.npmjs.com/package/@fleet-sdk/compiler)
 2 | 
 3 | Sigma.JS powered ErgoScript compiler.
 4 | 
 5 | ## Installation
 6 | 
 7 | ```bash
 8 | npm install @fleet-sdk/compiler
 9 | ```
10 | 


--------------------------------------------------------------------------------
/packages/compiler/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/compiler",
 3 |   "version": "0.8.2",
 4 |   "description": "Sigma.JS powered ErgoScript compiler.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "compiler"
31 |   ],
32 |   "dependencies": {
33 |     "@fleet-sdk/common": "workspace:^",
34 |     "@fleet-sdk/core": "workspace:^",
35 |     "@fleet-sdk/crypto": "workspace:^",
36 |     "@fleet-sdk/serializer": "workspace:^",
37 |     "sigmastate-js": "0.4.6"
38 |   },
39 |   "scripts": {
40 |     "build": "tsup --config ../../tsup.config.ts"
41 |   },
42 |   "engines": {
43 |     "node": ">=18"
44 |   },
45 |   "files": [
46 |     "dist",
47 |     "!**/*.spec.*",
48 |     "!**/*.json",
49 |     "!tests",
50 |     "CHANGELOG.md",
51 |     "LICENSE",
52 |     "README.md"
53 |   ]
54 | }
55 | 


--------------------------------------------------------------------------------
/packages/compiler/sigmastate-js.d.ts:
--------------------------------------------------------------------------------
 1 | declare module "sigmastate-js/main" {
 2 |   type SigmaCompilerNamedConstantsMap = { [key: string]: Value };
 3 |   type HexString = string;
 4 |   type ByteArray = { u: Int8Array };
 5 | 
 6 |   export declare class ErgoTree {
 7 |     toHex(): HexString;
 8 |     bytes(): ByteArray;
 9 |     header(): number;
10 |     version(): number;
11 |     isConstantSegregation(): boolean;
12 |     hasSize(): boolean;
13 |     constants(): Value[];
14 |     template(): ByteArray;
15 |     templateHex(): HexString;
16 |     toString(): string;
17 |   }
18 | 
19 |   export declare class ErgoTree$ {
20 |     static fromHex(value: HexString): ErgoTree;
21 |   }
22 | 
23 |   export declare class Type {
24 |     name: string;
25 |     toString(): string;
26 |   }
27 | 
28 |   export declare class Type$ {
29 |     static Byte: Type;
30 |     static Short: Type;
31 |     static Int: Type;
32 |     static Long: Type;
33 |     static BigInt: Type;
34 |     static GroupElement: Type;
35 |     static SigmaProp: Type;
36 |     static Box: Type;
37 |     static AvlTree: Type;
38 |     static Context: Type;
39 |     static Header: Type;
40 |     static PreHeader: Type;
41 |     static SigmaDslBuilder: Type;
42 |     static pairType(left: Type, right: Type): Type;
43 |     static collType(elemType: Type): Type;
44 |   }
45 | 
46 |   export declare class Value<T = unknown> {
47 |     data: T;
48 |     tpe: Type;
49 |     toHex(): HexString;
50 |   }
51 | 
52 |   export declare class Value$ {
53 |     static ofByte(value: number): Value<number>;
54 |     static ofShort(value: number): Value<number>;
55 |     static ofInt(value: number): Value<number>;
56 |     static ofLong(value: bigint): Value<bigint>;
57 |     static ofBigInt(value: bigint): Value<bigint>;
58 |     static pairOf<L, R>(left: Value<R>, right: Value<L>): Value<[L, R]>;
59 |     static collOf<T>(items: T[], type: Type): Value<T[]>;
60 |     static fromHex<T>(hex: HexString): Value<T>;
61 |   }
62 | 
63 |   export declare class SigmaCompiler {
64 |     compile(
65 |       namedConstants: SigmaCompilerNamedConstantsMap,
66 |       segregateConstants: boolean,
67 |       additionalHeaderFlags: number,
68 |       ergoScript: string
69 |     ): ErgoTree;
70 |   }
71 | 
72 |   export declare class SigmaCompiler$ {
73 |     static forMainnet(): SigmaCompiler;
74 |     static forTestnet(): SigmaCompiler;
75 |   }
76 | }
77 | 


--------------------------------------------------------------------------------
/packages/compiler/src/compilerOutput.ts:
--------------------------------------------------------------------------------
 1 | import { ErgoTree, type Network } from "@fleet-sdk/core";
 2 | import { hex } from "@fleet-sdk/crypto";
 3 | import type { ErgoTree as SigmaErgoTree, Value as SigmaValue } from "sigmastate-js/main";
 4 | import { ContractTemplate } from "./contractTemplate";
 5 | 
 6 | export class CompilerOutput extends ErgoTree {
 7 |   readonly #tree: SigmaErgoTree;
 8 |   #template?: ContractTemplate;
 9 | 
10 |   constructor(tree: SigmaErgoTree, network?: Network) {
11 |     super(hex.decode(tree.toHex()), network);
12 |     this.#tree = tree;
13 |   }
14 | 
15 |   get template(): ContractTemplate {
16 |     if (!this.#template) {
17 |       const templateBytes = hex.decode(this.#tree.templateHex());
18 |       this.#template = new ContractTemplate(templateBytes);
19 |     }
20 | 
21 |     return this.#template;
22 |   }
23 | 
24 |   get constants(): SigmaValue[] {
25 |     return this.#tree.constants();
26 |   }
27 | }
28 | 


--------------------------------------------------------------------------------
/packages/compiler/src/contractTemplate.ts:
--------------------------------------------------------------------------------
 1 | import { hex } from "@fleet-sdk/crypto";
 2 | 
 3 | export class ContractTemplate {
 4 |   private _bytes: Uint8Array;
 5 | 
 6 |   constructor(bytes: Uint8Array) {
 7 |     this._bytes = bytes;
 8 |   }
 9 | 
10 |   toBytes() {
11 |     return this._bytes;
12 |   }
13 | 
14 |   toHex() {
15 |     return hex.encode(this._bytes);
16 |   }
17 | }
18 | 


--------------------------------------------------------------------------------
/packages/compiler/src/index.ts:
--------------------------------------------------------------------------------
1 | export { compile } from "./compiler";
2 | export * from "./compilerOutput";
3 | export * from "./contractTemplate";
4 | 


--------------------------------------------------------------------------------
/packages/core/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/core/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/core",
 3 |   "version": "0.8.2",
 4 |   "description": "Fleet SDK core library",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "transactions",
31 |     "serialization"
32 |   ],
33 |   "scripts": {
34 |     "build": "tsup --config ../../tsup.config.ts"
35 |   },
36 |   "dependencies": {
37 |     "@fleet-sdk/common": "workspace:^",
38 |     "@fleet-sdk/crypto": "workspace:^",
39 |     "@fleet-sdk/serializer": "workspace:^"
40 |   },
41 |   "engines": {
42 |     "node": ">=18"
43 |   },
44 |   "files": [
45 |     "dist",
46 |     "!**/*.spec.*",
47 |     "!**/*.json",
48 |     "!tests",
49 |     "CHANGELOG.md",
50 |     "LICENSE",
51 |     "README.md"
52 |   ]
53 | }
54 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./selector";
2 | export * from "./outputBuilder";
3 | export * from "./transactionBuilder";
4 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/outputBuilder.test-d.ts:
--------------------------------------------------------------------------------
 1 | import { SBool, SInt, SLong } from "@fleet-sdk/serializer";
 2 | import { describe, expectTypeOf, it } from "vitest";
 3 | import { OutputBuilder, SAFE_MIN_BOX_VALUE } from "./outputBuilder";
 4 | 
 5 | describe("Sequential registers types", () => {
 6 |   const builder = new OutputBuilder(SAFE_MIN_BOX_VALUE, "9am...");
 7 | 
 8 |   it("Should accept sequential inputs", () => {
 9 |     expectTypeOf(
10 |       builder.setAdditionalRegisters({
11 |         R4: SInt(1),
12 |         R5: SBool(true).toHex()
13 |       })
14 |     ).toMatchTypeOf<OutputBuilder>();
15 | 
16 |     expectTypeOf(
17 |       builder.setAdditionalRegisters({
18 |         R4: SInt(1),
19 |         R5: SBool(true).toHex(),
20 |         R6: SLong(1n),
21 |         R7: SBool(false),
22 |         R8: SBool(true),
23 |         R9: SInt(10).toHex()
24 |       })
25 |     ).toMatchTypeOf<OutputBuilder>();
26 |   });
27 | 
28 |   it("Should not accept out-of-sequence inputs", () => {
29 |     // @ts-expect-error should now accept undefined params
30 |     builder.setAdditionalRegisters();
31 |     // @ts-expect-error skipped R4
32 |     builder.setAdditionalRegisters({ R5: SBool(true) });
33 |     // @ts-expect-error skipped R6 and R7
34 |     builder.setAdditionalRegisters({
35 |       R4: SBool(true),
36 |       R5: SInt(2),
37 |       R9: SBool(false)
38 |     });
39 |   });
40 | });
41 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/pluginContext.ts:
--------------------------------------------------------------------------------
 1 | import type {
 2 |   Amount,
 3 |   Box,
 4 |   CollectionAddOptions,
 5 |   OneOrMore,
 6 |   TokenAmount
 7 | } from "@fleet-sdk/common";
 8 | import { type OutputBuilder, type TransactionBuilder, NotAllowedTokenBurning } from "..";
 9 | 
10 | export type FleetPluginContext = {
11 |   /**
12 |    * Add and ensures selection of one or more inputs to the inputs list
13 |    * @param inputs
14 |    * @returns new list length
15 |    */
16 |   addInputs: (inputs: OneOrMore<Box<Amount>>) => number;
17 | 
18 |   /**
19 |    * Add one or more data inputs to the data inputs list
20 |    * @param dataInputs
21 |    * @returns new list length
22 |    */
23 |   addDataInputs: (
24 |     dataInputs: OneOrMore<Box<Amount>>,
25 |     options?: CollectionAddOptions
26 |   ) => number;
27 | 
28 |   /**
29 |    * Add one or more outputs to the outputs list
30 |    * @param outputs
31 |    * @param options
32 |    * @returns new list length
33 |    */
34 |   addOutputs: (
35 |     outputs: OneOrMore<OutputBuilder>,
36 |     options?: CollectionAddOptions
37 |   ) => number;
38 | 
39 |   /**
40 |    * Burn tokens
41 |    * @param tokens
42 |    * @throws Burning tokens thought a plugin, requires explicitly permission
43 |    * from {@link TransactionBuilder.configure}, if token burning is not allowed
44 |    * it will thrown a {@link NotAllowedTokenBurning} exception.
45 |    */
46 |   burnTokens: (tokens: OneOrMore<TokenAmount<Amount>>) => void;
47 | 
48 |   /**
49 |    * Set transaction fee amount
50 |    * @param amount amount in nanoergs
51 |    */
52 |   setFee: (amount: Amount) => void;
53 | };
54 | 
55 | export function createPluginContext(builder: TransactionBuilder): FleetPluginContext {
56 |   return {
57 |     addInputs: (inputs) => builder.from(inputs, { ensureInclusion: true }).inputs.length,
58 |     addOutputs: (outputs, options) => builder.to(outputs, options).outputs.length,
59 |     addDataInputs: (dataInputs, options) =>
60 |       builder.withDataFrom(dataInputs, options).dataInputs.length,
61 |     burnTokens: (tokens) => {
62 |       if (!builder.settings.canBurnTokensFromPlugins) throw new NotAllowedTokenBurning();
63 |       builder.burnTokens(tokens);
64 |     },
65 |     setFee: (amount) => builder.payFee(amount)
66 |   };
67 | }
68 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/index.ts:
--------------------------------------------------------------------------------
1 | export { BoxSelector } from "./boxSelector";
2 | export { AccumulativeSelectionStrategy } from "./strategies/accumulativeSelectionStrategy";
3 | export { CherryPickSelectionStrategy } from "./strategies/cherryPickSelectionStrategy";
4 | export { CustomSelectionStrategy } from "./strategies/customSelectionStrategy";
5 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/strategies/ISelectionStrategy.ts:
--------------------------------------------------------------------------------
1 | import type { Box } from "@fleet-sdk/common";
2 | import type { SelectionTarget } from "../boxSelector";
3 | 
4 | export interface ISelectionStrategy {
5 |   select(inputs: Box<bigint>[], target?: SelectionTarget): Box<bigint>[];
6 | }
7 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/strategies/accumulativeSelectionStrategy.spec.ts:
--------------------------------------------------------------------------------
 1 | import { sumBy, utxoSum } from "@fleet-sdk/common";
 2 | import { regularBoxes } from "_test-vectors";
 3 | import { describe, expect, it } from "vitest";
 4 | import { AccumulativeSelectionStrategy } from "./accumulativeSelectionStrategy";
 5 | 
 6 | describe("Accumulative selection strategy", () => {
 7 |   it("Should return an empty array if empty target: { nanoErgs: 0 }", () => {
 8 |     const selector = new AccumulativeSelectionStrategy();
 9 |     expect(selector.select(regularBoxes, { nanoErgs: 0n })).toEqual([]);
10 |   });
11 | 
12 |   it("Should select inputs for nanoErgs only with target amount", () => {
13 |     const selector = new AccumulativeSelectionStrategy();
14 |     const target = { nanoErgs: 10000n };
15 |     const boxes = selector.select(regularBoxes, target);
16 | 
17 |     expect(boxes).toHaveLength(1);
18 |     expect(sumBy(boxes, (x) => x.value)).toBeGreaterThanOrEqual(10000n);
19 |   });
20 | 
21 |   it("Should select all inputs with nanoErgs if no target amount is specified", () => {
22 |     const selector = new AccumulativeSelectionStrategy();
23 |     const boxes = selector.select(regularBoxes, { nanoErgs: undefined });
24 | 
25 |     expect(boxes).toHaveLength(regularBoxes.length);
26 |   });
27 | 
28 |   it("Should select all inputs with a given token if no target amount is specified", () => {
29 |     const selector = new AccumulativeSelectionStrategy();
30 | 
31 |     const boxes = selector.select(regularBoxes, {
32 |       tokens: [
33 |         {
34 |           tokenId: "007fd64d1ee54d78dd269c8930a38286caa28d3f29d27cadcb796418ab15c283"
35 |         }
36 |       ]
37 |     });
38 | 
39 |     expect(boxes).toHaveLength(3);
40 |     expect(sumBy(boxes, (x) => x.value)).toBeGreaterThanOrEqual(10000n);
41 |   });
42 | 
43 |   it("Should select all inputs with a given token if no target amount is specified - multiple tokenIds", () => {
44 |     const selector = new AccumulativeSelectionStrategy();
45 | 
46 |     const boxes = selector.select(regularBoxes, {
47 |       tokens: [
48 |         {
49 |           tokenId: "007fd64d1ee54d78dd269c8930a38286caa28d3f29d27cadcb796418ab15c283"
50 |         },
51 |         {
52 |           tokenId: "0cd8c9f416e5b1ca9f986a7f10a84191dfb85941619e49e53c0dc30ebf83324b"
53 |         }
54 |       ]
55 |     });
56 | 
57 |     expect(boxes).toHaveLength(4);
58 |     expect(sumBy(boxes, (x) => x.value)).toBeGreaterThanOrEqual(10000n);
59 |   });
60 | 
61 |   it("Should select inputs for tokens and nanoErgs", () => {
62 |     const selector = new AccumulativeSelectionStrategy();
63 |     const target = {
64 |       nanoErgs: 100000n,
65 |       tokens: [
66 |         {
67 |           tokenId: "0cd8c9f416e5b1ca9f986a7f10a84191dfb85941619e49e53c0dc30ebf83324b",
68 |           amount: 100n
69 |         },
70 |         {
71 |           tokenId: "007fd64d1ee54d78dd269c8930a38286caa28d3f29d27cadcb796418ab15c283",
72 |           amount: 10n
73 |         }
74 |       ]
75 |     };
76 |     const inputs = selector.select(regularBoxes, target);
77 | 
78 |     expect(inputs).toHaveLength(1); // should try to reuse already selected inputs
79 |     expect(sumBy(inputs, (x) => x.value)).toBeGreaterThanOrEqual(target.nanoErgs);
80 |     for (const t of target.tokens) {
81 |       expect(utxoSum(inputs, t.tokenId)).toBeGreaterThanOrEqual(t.amount);
82 |     }
83 |   });
84 | });
85 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/strategies/accumulativeSelectionStrategy.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   type Box,
 3 |   isDefined,
 4 |   some,
 5 |   type TokenId,
 6 |   type TokenTargetAmount
 7 | } from "@fleet-sdk/common";
 8 | import { _0n, isEmpty, isUndefined, sumBy, utxoSum } from "@fleet-sdk/common";
 9 | import type { SelectionTarget } from "../boxSelector";
10 | import type { ISelectionStrategy } from "./ISelectionStrategy";
11 | 
12 | /**
13 |  * Accumulative selection strategy accumulates inputs until the target amounts
14 |  * value is reached, skipping detrimental inputs.
15 |  */
16 | export class AccumulativeSelectionStrategy implements ISelectionStrategy {
17 |   private _inputs!: Box<bigint>[];
18 | 
19 |   select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[] {
20 |     this._inputs = inputs;
21 | 
22 |     let selection: Box<bigint>[] = [];
23 |     if (some(target.tokens)) {
24 |       selection = this._selectTokens(target.tokens);
25 |     }
26 | 
27 |     const selectedNanoErgs = sumBy(selection, (input) => input.value);
28 |     if (
29 |       (isUndefined(target.nanoErgs) && isEmpty(target.tokens)) ||
30 |       (isDefined(target.nanoErgs) && selectedNanoErgs < target.nanoErgs)
31 |     ) {
32 |       const targetAmount = isDefined(target.nanoErgs)
33 |         ? target.nanoErgs - selectedNanoErgs
34 |         : undefined;
35 | 
36 |       selection = selection.concat(this._select(targetAmount));
37 |     }
38 | 
39 |     return selection;
40 |   }
41 | 
42 |   private _selectTokens(targets: TokenTargetAmount<bigint>[]): Box<bigint>[] {
43 |     let selection: Box<bigint>[] = [];
44 | 
45 |     for (const target of targets) {
46 |       const targetAmount = isDefined(target.amount)
47 |         ? target.amount - utxoSum(selection, target.tokenId)
48 |         : undefined;
49 | 
50 |       if (targetAmount && targetAmount <= _0n) {
51 |         continue;
52 |       }
53 | 
54 |       selection = selection.concat(this._select(targetAmount, target.tokenId));
55 |     }
56 | 
57 |     return selection;
58 |   }
59 | 
60 |   private _select(target?: bigint, tokenId?: TokenId): Box<bigint>[] {
61 |     const inputs = this._inputs;
62 |     let acc = _0n;
63 |     let selection: Box<bigint>[] = [];
64 | 
65 |     if (isUndefined(target)) {
66 |       if (tokenId) {
67 |         selection = inputs.filter((x) =>
68 |           x.assets.some((asset) => asset.tokenId === tokenId)
69 |         );
70 |       } else {
71 |         selection = inputs;
72 |       }
73 |     } else {
74 |       for (let i = 0; i < inputs.length && acc < target; i++) {
75 |         if (tokenId) {
76 |           for (const token of inputs[i].assets) {
77 |             if (token.tokenId !== tokenId) {
78 |               continue;
79 |             }
80 | 
81 |             acc += token.amount;
82 |             selection.push(inputs[i]);
83 |           }
84 |         } else {
85 |           acc += inputs[i].value;
86 |           selection.push(inputs[i]);
87 |         }
88 |       }
89 |     }
90 | 
91 |     if (some(selection)) {
92 |       this._inputs = this._inputs.filter((input) => !selection.includes(input));
93 |     }
94 | 
95 |     return selection;
96 |   }
97 | }
98 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/strategies/cherryPickSelectionStrategy.ts:
--------------------------------------------------------------------------------
 1 | import { type Box, orderBy } from "@fleet-sdk/common";
 2 | import type { SelectionTarget } from "../boxSelector";
 3 | import { AccumulativeSelectionStrategy } from "./accumulativeSelectionStrategy";
 4 | 
 5 | /**
 6 |  * The Cherry Pick strategy accumulates inputs until the target amounts trying
 7 |  * to pick inputs with as less as possible unused tokens.
 8 |  */
 9 | export class CherryPickSelectionStrategy extends AccumulativeSelectionStrategy {
10 |   public override select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[] {
11 |     const orderedInputs = orderBy(
12 |       inputs,
13 |       (x) => new Set(x.assets.map((asset) => asset.tokenId)).size,
14 |       "asc"
15 |     );
16 | 
17 |     return super.select(orderedInputs, target);
18 |   }
19 | }
20 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/strategies/customSelectionStrategy.spec.ts:
--------------------------------------------------------------------------------
 1 | import type { Box } from "@fleet-sdk/common";
 2 | import { regularBoxes } from "_test-vectors";
 3 | import { describe, expect, it, vi } from "vitest";
 4 | import { CustomSelectionStrategy } from "./customSelectionStrategy";
 5 | 
 6 | describe("Custom selection strategy", () => {
 7 |   it("Should use custom selection function to select boxes", () => {
 8 |     const mockSelector = vi.fn((inputs: Box<bigint>[]) => {
 9 |       return inputs;
10 |     });
11 |     const selection = new CustomSelectionStrategy(mockSelector);
12 | 
13 |     expect(selection.select(regularBoxes)).toBe(regularBoxes);
14 |     expect(mockSelector).toBeCalled();
15 |   });
16 | });
17 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/selector/strategies/customSelectionStrategy.ts:
--------------------------------------------------------------------------------
 1 | import type { Box } from "@fleet-sdk/common";
 2 | import type { SelectionTarget } from "../boxSelector";
 3 | import type { ISelectionStrategy } from "./ISelectionStrategy";
 4 | 
 5 | export type SelectorFunction = (
 6 |   inputs: Box<bigint>[],
 7 |   target?: SelectionTarget
 8 | ) => Box<bigint>[];
 9 | 
10 | /**
11 |  * Custom selection strategy supports custom selections implementations.
12 |  */
13 | export class CustomSelectionStrategy implements ISelectionStrategy {
14 |   private readonly _selector: SelectorFunction;
15 | 
16 |   constructor(selector: SelectorFunction) {
17 |     this._selector = selector;
18 |   }
19 | 
20 |   select(inputs: Box<bigint>[], target?: SelectionTarget): Box<bigint>[] {
21 |     return this._selector(inputs, target);
22 |   }
23 | }
24 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/transactionBuilderSettings.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { MAX_TOKENS_PER_BOX } from "../models";
 3 | import { TransactionBuilderSettings } from "./transactionBuilderSettings";
 4 | 
 5 | describe("Transaction builder settings", () => {
 6 |   it("Should hold defaults on constructing", () => {
 7 |     const settings = new TransactionBuilderSettings();
 8 |     expect(settings.canBurnTokens).toBeFalsy();
 9 |     expect(settings.canBurnTokensFromPlugins).toBeFalsy();
10 |     expect(settings.maxTokensPerChangeBox).toBe(MAX_TOKENS_PER_BOX);
11 |     expect(settings.shouldIsolateErgOnChange).toBeFalsy();
12 |   });
13 | 
14 |   it("Should reflect changes", () => {
15 |     const settings = new TransactionBuilderSettings()
16 |       .allowTokenBurning(true)
17 |       .allowTokenBurningFromPlugins(true)
18 |       .setMaxTokensPerChangeBox(50)
19 |       .isolateErgOnChange(true);
20 | 
21 |     expect(settings.canBurnTokens).toBe(true);
22 |     expect(settings.canBurnTokensFromPlugins).toBe(true);
23 |     expect(settings.maxTokensPerChangeBox).toBe(50);
24 |     expect(settings.shouldIsolateErgOnChange).toBe(true);
25 | 
26 |     settings.allowTokenBurning(false);
27 | 
28 |     expect(settings.canBurnTokens).toBe(false);
29 |     expect(settings.canBurnTokensFromPlugins).toBe(true);
30 |   });
31 | 
32 |   it("Should set true by default for boolean methods", () => {
33 |     const setting = new TransactionBuilderSettings()
34 |       .allowTokenBurning(false)
35 |       .allowTokenBurningFromPlugins(false)
36 |       .isolateErgOnChange(false);
37 | 
38 |     expect(setting.canBurnTokens).toBeFalsy();
39 |     expect(setting.canBurnTokensFromPlugins).toBeFalsy();
40 |     expect(setting.shouldIsolateErgOnChange).toBeFalsy();
41 | 
42 |     setting.allowTokenBurning().allowTokenBurningFromPlugins().isolateErgOnChange();
43 |     expect(setting.canBurnTokens).toBeTruthy();
44 |     expect(setting.canBurnTokensFromPlugins).toBeTruthy();
45 |     expect(setting.shouldIsolateErgOnChange).toBeTruthy();
46 |   });
47 | 
48 |   it("Should allow token burning from plugins if it's globally allowed", () => {
49 |     const settings = new TransactionBuilderSettings().allowTokenBurning(true);
50 | 
51 |     expect(settings.canBurnTokens).toBe(true);
52 |     expect(settings.canBurnTokensFromPlugins).toBe(true);
53 |   });
54 | 
55 |   it("Should allow token burning only from plugins context", () => {
56 |     const settings = new TransactionBuilderSettings().allowTokenBurningFromPlugins(true);
57 | 
58 |     expect(settings.canBurnTokens).toBe(false);
59 |     expect(settings.canBurnTokensFromPlugins).toBe(true);
60 |   });
61 | });
62 | 


--------------------------------------------------------------------------------
/packages/core/src/builder/transactionBuilderSettings.ts:
--------------------------------------------------------------------------------
 1 | import { MAX_TOKENS_PER_BOX } from "../models";
 2 | 
 3 | export class TransactionBuilderSettings {
 4 |   private _maxDistinctTokensPerChangeBox: number;
 5 |   private _allowTokenBurning: boolean;
 6 |   private _allowTokenBurningFromPlugins: boolean;
 7 |   private _isolateErgOnChange: boolean;
 8 | 
 9 |   constructor() {
10 |     this._maxDistinctTokensPerChangeBox = MAX_TOKENS_PER_BOX;
11 |     this._allowTokenBurning = false;
12 |     this._allowTokenBurningFromPlugins = false;
13 |     this._isolateErgOnChange = false;
14 |   }
15 | 
16 |   public get maxTokensPerChangeBox(): number {
17 |     return this._maxDistinctTokensPerChangeBox;
18 |   }
19 | 
20 |   public get canBurnTokens(): boolean {
21 |     return this._allowTokenBurning;
22 |   }
23 | 
24 |   public get canBurnTokensFromPlugins(): boolean {
25 |     return this.canBurnTokens || this._allowTokenBurningFromPlugins;
26 |   }
27 | 
28 |   public get shouldIsolateErgOnChange(): boolean {
29 |     return this._isolateErgOnChange;
30 |   }
31 | 
32 |   /**
33 |    * Define max number of distinct tokens per change box
34 |    */
35 |   public setMaxTokensPerChangeBox(max: number): TransactionBuilderSettings {
36 |     this._maxDistinctTokensPerChangeBox = max;
37 | 
38 |     return this;
39 |   }
40 | 
41 |   /**
42 |    * Allows or denies token burning from all contexts
43 |    */
44 |   public allowTokenBurning(allow = true): TransactionBuilderSettings {
45 |     this._allowTokenBurning = allow;
46 | 
47 |     return this;
48 |   }
49 | 
50 |   /**
51 |    * Allows or denies token burning **only** from plugins context.
52 |    */
53 |   public allowTokenBurningFromPlugins(allow = true): TransactionBuilderSettings {
54 |     this._allowTokenBurningFromPlugins = allow;
55 | 
56 |     return this;
57 |   }
58 | 
59 |   /**
60 |    * If true, it creates an exclusive change box only for ERG.
61 |    * This setting is especially useful for Ledger devices to
62 |    * help on avoiding to hit the max tokens limit per transaction.
63 |    */
64 |   public isolateErgOnChange(isolate = true): TransactionBuilderSettings {
65 |     this._isolateErgOnChange = isolate;
66 | 
67 |     return this;
68 |   }
69 | }
70 | 


--------------------------------------------------------------------------------
/packages/core/src/constantSerializer.spec.ts:
--------------------------------------------------------------------------------
  1 | import { hex, randomBytes } from "@fleet-sdk/crypto";
  2 | import { describe, expect, it } from "vitest";
  3 | import {
  4 |   SBigInt,
  5 |   SBool,
  6 |   SByte,
  7 |   SColl,
  8 |   SConstant,
  9 |   SGroupElement,
 10 |   SInt,
 11 |   SLong,
 12 |   SParse,
 13 |   SShort,
 14 |   SSigmaProp,
 15 |   SUnit
 16 | } from "./constantSerializer";
 17 | 
 18 | describe("Serialize -> Parse roundtrip", () => {
 19 |   function randomInt(min: number, max: number) {
 20 |     const mn = Math.ceil(min);
 21 |     const mx = Math.floor(max);
 22 | 
 23 |     return Math.floor(Math.random() * (mx - mn + 1)) + mn;
 24 |   }
 25 | 
 26 |   function getRandomBigInt(bytes: number) {
 27 |     return BigInt(`0x${hex.encode(randomBytes(bytes))}`);
 28 |   }
 29 | 
 30 |   function randomBigInt(min: bigint, max: bigint) {
 31 |     // increase the chances of negative numbers generation;
 32 |     const rand =
 33 |       getRandomBigInt(1) % 2n === 0n ? getRandomBigInt(1) : getRandomBigInt(1) * -1n;
 34 | 
 35 |     return (rand * (max - min + 1n) + min) / 10_000n;
 36 |   }
 37 | 
 38 |   it("Should roundtrip SColl", () => {
 39 |     const intVal = [1, 2, 3];
 40 |     expect(SParse(SConstant(SColl(SInt, intVal)))).toEqual(intVal);
 41 | 
 42 |     const hexVal = "deadbeef";
 43 |     expect(SParse(SConstant(SColl(SByte, hexVal)))).to.be.deep.equal(hex.decode(hexVal));
 44 | 
 45 |     const bytes = hex.decode(hexVal);
 46 |     expect(SParse(SConstant(SColl(SByte, bytes)))).to.be.deep.equal(bytes);
 47 |   });
 48 | 
 49 |   it("Should serialize SUnit", () => {
 50 |     expect(SConstant(SUnit())).toBe("62");
 51 |   });
 52 | 
 53 |   it("Should roundtrip SBoolean", () => {
 54 |     expect(SParse(SConstant(SBool(true)))).toBe(true);
 55 |     expect(SParse(SConstant(SBool(false)))).toBe(false);
 56 |   });
 57 | 
 58 |   it("Should roundtrip SByte", () => {
 59 |     const value = randomInt(0, 127);
 60 |     expect(SParse(SConstant(SByte(value)))).toBe(value);
 61 |   });
 62 | 
 63 |   it("Should roundtrip SShort", () => {
 64 |     const value = randomInt(-32_768, 32_767);
 65 |     expect(SParse(SConstant(SShort(value)))).toBe(value);
 66 |   });
 67 | 
 68 |   it("Should roundtrip SInt", () => {
 69 |     // https://docs.scala-lang.org/overviews/scala-book/built-in-types.html
 70 | 
 71 |     const value = randomInt(-2_147_483_648, 2_147_483_647);
 72 |     expect(SParse(SConstant(SInt(value)))).toBe(value);
 73 |   });
 74 | 
 75 |   it("Should roundtrip SLong", () => {
 76 |     const value = randomBigInt(-9_223_372_036_854_775_808n, 9_223_372_036_854_775_807n);
 77 |     expect(SParse(SConstant(SLong(value)))).toBe(value);
 78 |   });
 79 | 
 80 |   it("Should roundtrip SBigInt", () => {
 81 |     const value = randomBigInt(
 82 |       -9_223_372_036_854_775_808_000n,
 83 |       9_223_372_036_854_775_807_000n
 84 |     );
 85 |     expect(SParse(SConstant(SBigInt(value)))).toBe(value);
 86 |   });
 87 | 
 88 |   it("Should roundtrip SGroupElement", () => {
 89 |     const value = hex.decode(
 90 |       "02000031a06023f7d372f748a816db1765b4e4f1989cf89791c021a37ce09dae37"
 91 |     );
 92 |     expect(SParse(SConstant(SGroupElement(value)))).toEqual(value);
 93 |   });
 94 | 
 95 |   it("Should roundtrip SSigmaProp", () => {
 96 |     const value = hex.decode(
 97 |       "0200c662d546939237a0195ef8be81fb0f939285c374b3589cc5d7172c98e33b22"
 98 |     );
 99 |     expect(SParse(SConstant(SSigmaProp(SGroupElement(value))))).toEqual(value);
100 |   });
101 | });
102 | 


--------------------------------------------------------------------------------
/packages/core/src/constantSerializer.ts:
--------------------------------------------------------------------------------
 1 | import type { HexString } from "@fleet-sdk/common";
 2 | import {
 3 |   SBigInt,
 4 |   SBool,
 5 |   SByte,
 6 |   SColl,
 7 |   SCollType,
 8 |   SConstant as SerSConstant,
 9 |   SGroupElement,
10 |   SInt,
11 |   SLong,
12 |   SShort,
13 |   SSigmaProp,
14 |   SType,
15 |   SUnit
16 | } from "@fleet-sdk/serializer";
17 | 
18 | /**
19 |  * @deprecated Use {@link @fleet-sdk/serializer} instead.
20 |  * This function will be removed from core package in v1.0.0.
21 |  */
22 | export function SConstant(constant: SerSConstant): HexString {
23 |   return constant.toHex();
24 | }
25 | 
26 | /**
27 |  * @deprecated Use {@link @fleet-sdk/serializer} instead.
28 |  * This function will be removed from core package in v1.0.0.
29 |  */
30 | export function SParse<T>(bytes: HexString | Uint8Array): T {
31 |   return SerSConstant.from<T>(bytes).data;
32 | }
33 | 
34 | export {
35 |   SBigInt,
36 |   SBool,
37 |   SByte,
38 |   SCollType,
39 |   SColl,
40 |   SGroupElement,
41 |   SInt,
42 |   SLong,
43 |   SShort,
44 |   SSigmaProp,
45 |   SType,
46 |   SUnit
47 | };
48 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/duplicateInputError.ts:
--------------------------------------------------------------------------------
1 | export class DuplicateInputError extends Error {
2 |   constructor(boxId: string) {
3 |     super(`Box '${boxId}' is already included.`);
4 |   }
5 | }
6 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/duplicateInputSelectionError.ts:
--------------------------------------------------------------------------------
1 | export class DuplicateInputSelectionError extends Error {
2 |   constructor() {
3 |     super(
4 |       "One or more inputs was selected more than one time by the current selection strategy."
5 |     );
6 |   }
7 | }
8 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/index.ts:
--------------------------------------------------------------------------------
 1 | export * from "./duplicateInputError";
 2 | export * from "./duplicateInputSelectionError";
 3 | export * from "./insufficientInputs";
 4 | export * from "./insufficientTokenAmount";
 5 | export * from "./invalidAddress";
 6 | export * from "./invalidInput";
 7 | export * from "./invalidRegistersPacking";
 8 | export * from "./malformedTransaction";
 9 | export * from "./maxTokensOverflow";
10 | export * from "./notAllowedTokenBurning";
11 | export * from "./notFoundError";
12 | export * from "./undefinedCreationHeight";
13 | export * from "./undefinedMintingContext";
14 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/insufficientInputs.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { InsufficientInputs } from "./insufficientInputs";
 3 | 
 4 | describe("Insufficient inputs error", () => {
 5 |   it("Should hold details and return formatted error message", () => {
 6 |     const unreached = {
 7 |       nanoErgs: 10n,
 8 |       tokens: [
 9 |         {
10 |           tokenId: "007fd64d1ee54d78dd269c8930a38286caa28d3f29d27cadcb796418ab15c283",
11 |           amount: 100n
12 |         }
13 |       ]
14 |     };
15 | 
16 |     const error = new InsufficientInputs(unreached);
17 | 
18 |     expect(error.unreached).toEqual(unreached);
19 |     expect(
20 |       error.message.includes("nanoErgs") &&
21 |         error.message.includes(
22 |           "007fd64d1ee54d78dd269c8930a38286caa28d3f29d27cadcb796418ab15c283"
23 |         )
24 |     ).toBeTruthy();
25 |   });
26 | });
27 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/insufficientInputs.ts:
--------------------------------------------------------------------------------
 1 | import { some } from "@fleet-sdk/common";
 2 | import type { SelectionTarget } from "../builder/selector/boxSelector";
 3 | 
 4 | export class InsufficientInputs extends Error {
 5 |   readonly unreached: SelectionTarget;
 6 | 
 7 |   constructor(unreached: SelectionTarget) {
 8 |     const strings = [];
 9 |     if (unreached.nanoErgs) {
10 |       strings.push(buildString("nanoErgs", unreached.nanoErgs));
11 |     }
12 | 
13 |     if (some(unreached.tokens)) {
14 |       for (const token of unreached.tokens) {
15 |         strings.push(buildString(token.tokenId, token.amount));
16 |       }
17 |     }
18 | 
19 |     super(`Insufficient inputs:${strings.join()}`);
20 | 
21 |     this.unreached = unreached;
22 |   }
23 | }
24 | 
25 | function buildString(tokenId: string, amount?: bigint): string {
26 |   return `\n  > ${tokenId}: ${amount?.toString()}`;
27 | }
28 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/insufficientTokenAmount.ts:
--------------------------------------------------------------------------------
1 | export class InsufficientTokenAmount extends Error {}
2 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/invalidAddress.ts:
--------------------------------------------------------------------------------
1 | export class InvalidAddress extends Error {
2 |   constructor(address: string) {
3 |     super(`Invalid Ergo address: ${address}`);
4 |   }
5 | }
6 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/invalidInput.ts:
--------------------------------------------------------------------------------
1 | export class InvalidInput extends Error {
2 |   constructor(boxId: string) {
3 |     super(`Invalid input: ${boxId}`);
4 |   }
5 | }
6 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/invalidRegistersPacking.ts:
--------------------------------------------------------------------------------
1 | export class InvalidRegistersPacking extends Error {
2 |   constructor() {
3 |     super(
4 |       `Registers should be densely packed. This means that it's not possible to use a register like 'R7' without filling 'R6', 'R5' and 'R4', for example.`
5 |     );
6 |   }
7 | }
8 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/malformedTransaction.ts:
--------------------------------------------------------------------------------
1 | export class MalformedTransaction extends Error {
2 |   constructor(message: string) {
3 |     super(`Malformed transaction: ${message}`);
4 |   }
5 | }
6 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/maxTokensOverflow.ts:
--------------------------------------------------------------------------------
1 | import { MAX_TOKENS_PER_BOX } from "../models/collections/tokensCollection";
2 | 
3 | export class MaxTokensOverflow extends Error {
4 |   constructor() {
5 |     super(`A box must contain no more than ${MAX_TOKENS_PER_BOX} distinct tokens.`);
6 |   }
7 | }
8 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/nonStandardizedMinting.ts:
--------------------------------------------------------------------------------
1 | export class NonStandardizedMinting extends Error {}
2 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/notAllowedTokenBurning.ts:
--------------------------------------------------------------------------------
1 | export class NotAllowedTokenBurning extends Error {
2 |   constructor() {
3 |     super(
4 |       "This transaction is trying to burn tokens. If that's your intention you must explicitly allow token burning on TransactionBuilder.configure() method. If no, a change address should be provided."
5 |     );
6 |   }
7 | }
8 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/notFoundError.ts:
--------------------------------------------------------------------------------
1 | export class NotFoundError extends Error {}
2 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/undefinedCreationHeight.ts:
--------------------------------------------------------------------------------
1 | export class UndefinedCreationHeight extends Error {
2 |   constructor() {
3 |     super(
4 |       "Minting context is undefined. Transaction's inputs must be included in order to determine minting token id."
5 |     );
6 |   }
7 | }
8 | 


--------------------------------------------------------------------------------
/packages/core/src/errors/undefinedMintingContext.ts:
--------------------------------------------------------------------------------
1 | export class UndefinedMintingContext extends Error {
2 |   constructor() {
3 |     super("Creation Height is undefined.");
4 |   }
5 | }
6 | 


--------------------------------------------------------------------------------
/packages/core/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./builder";
2 | export * from "./models";
3 | export * from "./errors";
4 | export * from "./constantSerializer";
5 | export { AddressType, Network } from "@fleet-sdk/common";
6 | export type { Box, Amount, TokenAmount } from "@fleet-sdk/common";
7 | 


--------------------------------------------------------------------------------
/packages/core/src/models/collections/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./tokensCollection";
2 | export * from "./inputsCollection";
3 | export * from "./outputsCollection";
4 | 


--------------------------------------------------------------------------------
/packages/core/src/models/collections/inputsCollection.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   type Amount,
 3 |   type Box,
 4 |   type BoxId,
 5 |   type OneOrMore,
 6 |   Collection
 7 | } from "@fleet-sdk/common";
 8 | import { isDefined } from "@fleet-sdk/common";
 9 | import { DuplicateInputError, NotFoundError } from "../../errors";
10 | import { ErgoUnsignedInput } from "../ergoUnsignedInput";
11 | 
12 | export class InputsCollection extends Collection<ErgoUnsignedInput, Box<Amount>> {
13 |   constructor();
14 |   constructor(box: Box<Amount>);
15 |   constructor(boxes: Box<Amount>[]);
16 |   constructor(boxes?: OneOrMore<Box<Amount>>) {
17 |     super();
18 |     if (isDefined(boxes)) this.add(boxes);
19 |   }
20 | 
21 |   protected override _map(input: Box<Amount> | ErgoUnsignedInput): ErgoUnsignedInput {
22 |     return input instanceof ErgoUnsignedInput ? input : new ErgoUnsignedInput(input);
23 |   }
24 | 
25 |   protected override _addOne(box: Box<Amount>): number {
26 |     if (this._items.some((item) => item.boxId === box.boxId)) {
27 |       throw new DuplicateInputError(box.boxId);
28 |     }
29 | 
30 |     return super._addOne(box);
31 |   }
32 | 
33 |   public remove(boxId: BoxId): number;
34 |   public remove(index: number): number;
35 |   public remove(boxIdOrIndex: BoxId | number): number {
36 |     let index = -1;
37 |     if (typeof boxIdOrIndex === "number") {
38 |       if (this._isIndexOutOfBounds(boxIdOrIndex)) {
39 |         throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);
40 |       }
41 | 
42 |       index = boxIdOrIndex;
43 |     } else {
44 |       index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);
45 | 
46 |       if (this._isIndexOutOfBounds(index)) {
47 |         throw new NotFoundError(
48 |           "The input you are trying to remove is not present in the inputs collection."
49 |         );
50 |       }
51 |     }
52 | 
53 |     this._items.splice(index, 1);
54 |     return this.length;
55 |   }
56 | }
57 | 


--------------------------------------------------------------------------------
/packages/core/src/models/collections/outputsCollection.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   _0n,
 3 |   type BoxSummary,
 4 |   Collection,
 5 |   isDefined,
 6 |   isUndefined,
 7 |   type OneOrMore,
 8 |   some
 9 | } from "@fleet-sdk/common";
10 | import type { OutputBuilder } from "../../builder/outputBuilder";
11 | import type { SelectionTarget } from "../../builder/selector/boxSelector";
12 | import { NotFoundError } from "../../errors";
13 | 
14 | function setSum<K>(map: Map<K, bigint>, key: K, value: bigint) {
15 |   return map.set(key, (map.get(key) || _0n) + value);
16 | }
17 | 
18 | export class OutputsCollection extends Collection<OutputBuilder, OutputBuilder> {
19 |   constructor(outputs?: OneOrMore<OutputBuilder>) {
20 |     super();
21 |     if (isDefined(outputs)) this.add(outputs);
22 |   }
23 | 
24 |   protected _map(output: OutputBuilder) {
25 |     return output;
26 |   }
27 | 
28 |   remove(output: OutputBuilder): number;
29 |   remove(index: number): number;
30 |   remove(outputs: OutputBuilder | number): number {
31 |     let index = -1;
32 |     if (typeof outputs === "number") {
33 |       if (this._isIndexOutOfBounds(outputs)) {
34 |         throw new RangeError(`Index '${outputs}' is out of range.`);
35 |       }
36 | 
37 |       index = outputs;
38 |     } else {
39 |       index = this._items.lastIndexOf(outputs);
40 | 
41 |       if (this._isIndexOutOfBounds(index)) {
42 |         throw new NotFoundError(
43 |           "The output you are trying to remove is not present in the outputs collection."
44 |         );
45 |       }
46 |     }
47 | 
48 |     this._items.splice(index, 1);
49 | 
50 |     return this.length;
51 |   }
52 | 
53 |   clone(): OutputsCollection {
54 |     return new OutputsCollection(this._items);
55 |   }
56 | 
57 |   sum(basis?: SelectionTarget | BoxSummary): BoxSummary {
58 |     const tokens = new Map<string, bigint>();
59 |     let nanoErgs = _0n;
60 | 
61 |     if (basis) {
62 |       if (basis.nanoErgs) {
63 |         nanoErgs = basis.nanoErgs;
64 |       }
65 | 
66 |       if (some(basis.tokens)) {
67 |         for (const token of basis.tokens) {
68 |           if (isUndefined(token.amount)) continue;
69 | 
70 |           setSum(tokens, token.tokenId, token.amount);
71 |         }
72 |       }
73 |     }
74 | 
75 |     for (const box of this._items) {
76 |       nanoErgs += box.value;
77 |       for (const token of box.assets) {
78 |         if (token.tokenId) setSum(tokens, token.tokenId, token.amount);
79 |       }
80 |     }
81 | 
82 |     return {
83 |       nanoErgs,
84 |       tokens: Array.from(tokens, ([tokenId, amount]) => ({ tokenId, amount }))
85 |     };
86 |   }
87 | }
88 | 


--------------------------------------------------------------------------------
/packages/core/src/models/ergoBox.spec.ts:
--------------------------------------------------------------------------------
 1 | import type { Amount, BoxCandidate, NonMandatoryRegisters, Box } from "@fleet-sdk/common";
 2 | import {
 3 |   invalidBoxes,
 4 |   manyTokensBoxes,
 5 |   outOfOrderRegistersBox,
 6 |   regularBoxes,
 7 |   validBoxes
 8 | } from "_test-vectors";
 9 | import { describe, expect, it, test } from "vitest";
10 | import { ErgoBox } from "./ergoBox";
11 | 
12 | describe("Construction", () => {
13 |   test.each(regularBoxes)("Should construct from a vanilla object", (tv) => {
14 |     const ergoBox = new ErgoBox(tv);
15 | 
16 |     expect(ergoBox.boxId).toBe(tv.boxId);
17 |     expect(ergoBox.value).toBe(tv.value);
18 |     expect(ergoBox.ergoTree).toBe(tv.ergoTree);
19 |     expect(ergoBox.assets).toEqual(tv.assets);
20 |     expect(ergoBox.creationHeight).toBe(tv.creationHeight);
21 |     expect(ergoBox.additionalRegisters).toBe(tv.additionalRegisters);
22 |     expect(ergoBox.transactionId).toBe(tv.transactionId);
23 |     expect(ergoBox.index).toBe(tv.index);
24 |   });
25 | 
26 |   test.each(regularBoxes)("Should construct from a candidate and compute boxId", (tv) => {
27 |     const ergoBox = new ErgoBox(boxToCandidate(tv), tv.transactionId, tv.index);
28 | 
29 |     expect(ergoBox.boxId).to.be.equal(tv.boxId);
30 |     expect(ergoBox.transactionId).to.be.equal(tv.transactionId);
31 |     expect(ergoBox.index).to.be.equal(tv.index);
32 |   });
33 | 
34 |   it("Should throw if transactionId or index is not provided for box candidate", () => {
35 |     const box = regularBoxes[0];
36 |     const candidate = boxToCandidate(box);
37 | 
38 |     expect(
39 |       () => new ErgoBox(candidate, undefined as unknown as string, box.index)
40 |     ).to.throw("TransactionId and Index must be provided for Box generation.");
41 | 
42 |     expect(
43 |       () => new ErgoBox(candidate, box.transactionId, undefined as unknown as number)
44 |     ).to.throw("TransactionId and Index must be provided for Box generation.");
45 |   });
46 | });
47 | 
48 | describe("Validation", () => {
49 |   it("Should validate valid boxes", () => {
50 |     for (const box of regularBoxes) {
51 |       expect(ErgoBox.validate(box)).toBeTruthy();
52 |     }
53 | 
54 |     for (const box of manyTokensBoxes) {
55 |       expect(ErgoBox.validate(box)).toBeTruthy();
56 |       new ErgoBox(box);
57 |     }
58 | 
59 |     for (const box of validBoxes) {
60 |       expect(new ErgoBox<NonMandatoryRegisters>(box).isValid()).toBeTruthy();
61 |     }
62 | 
63 |     expect(new ErgoBox(outOfOrderRegistersBox).isValid()).toBeTruthy();
64 |   });
65 | 
66 |   it("Should not validate invalid boxes", () => {
67 |     for (const box of invalidBoxes) {
68 |       expect(ErgoBox.validate(box)).toBeFalsy();
69 |       expect(new ErgoBox<NonMandatoryRegisters>(box).isValid()).toBeFalsy();
70 |     }
71 |   });
72 | });
73 | 
74 | function boxToCandidate(tv: Box<bigint>): BoxCandidate<Amount, NonMandatoryRegisters> {
75 |   return {
76 |     value: tv.value,
77 |     ergoTree: tv.ergoTree,
78 |     creationHeight: tv.creationHeight,
79 |     assets: tv.assets,
80 |     additionalRegisters: tv.additionalRegisters
81 |   };
82 | }
83 | 


--------------------------------------------------------------------------------
/packages/core/src/models/ergoBoxCandidate.ts:
--------------------------------------------------------------------------------
 1 | import type {
 2 |   NonMandatoryRegisters,
 3 |   TokenAmount,
 4 |   BoxCandidate,
 5 |   Amount
 6 | } from "@fleet-sdk/common";
 7 | import { ensureBigInt } from "@fleet-sdk/common";
 8 | import { ErgoBox } from "./ergoBox";
 9 | import type { TransactionOutputFlags } from "../builder";
10 | 
11 | export class ErgoBoxCandidate<R extends NonMandatoryRegisters = NonMandatoryRegisters> {
12 |   value: bigint;
13 |   ergoTree: string;
14 |   creationHeight: number;
15 |   assets: TokenAmount<bigint>[];
16 |   additionalRegisters: R;
17 |   flags?: TransactionOutputFlags;
18 | 
19 |   constructor(candidate: BoxCandidate<Amount, R>, flags?: TransactionOutputFlags) {
20 |     this.ergoTree = candidate.ergoTree;
21 |     this.creationHeight = candidate.creationHeight;
22 |     this.value = ensureBigInt(candidate.value);
23 |     this.assets = candidate.assets.map((asset) => ({
24 |       tokenId: asset.tokenId,
25 |       amount: ensureBigInt(asset.amount)
26 |     }));
27 |     this.additionalRegisters = candidate.additionalRegisters;
28 |     this.flags = flags;
29 |   }
30 | 
31 |   toBox(transactionId: string, index: number): ErgoBox<R> {
32 |     return new ErgoBox(this, transactionId, index);
33 |   }
34 | 
35 |   toPlainObject(): BoxCandidate<string> {
36 |     return {
37 |       value: this.value.toString(),
38 |       ergoTree: this.ergoTree,
39 |       creationHeight: this.creationHeight,
40 |       assets: this.assets.map((asset) => ({
41 |         tokenId: asset.tokenId,
42 |         amount: asset.amount.toString()
43 |       })),
44 |       additionalRegisters: this.additionalRegisters
45 |     };
46 |   }
47 | }
48 | 


--------------------------------------------------------------------------------
/packages/core/src/models/ergoTree.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   ergoTreeHeaderFlags,
 3 |   Network,
 4 |   type Base58String,
 5 |   type HexString
 6 | } from "@fleet-sdk/common";
 7 | import { hex } from "@fleet-sdk/crypto";
 8 | import { ErgoAddress } from "./ergoAddress";
 9 | 
10 | const VERSION_MASK = 0x07;
11 | 
12 | export class ErgoTree {
13 |   #bytes: Uint8Array;
14 |   #network: Network;
15 | 
16 |   constructor(input: HexString | Uint8Array, network?: Network) {
17 |     if (typeof input === "string") {
18 |       this.#bytes = hex.decode(input);
19 |     } else {
20 |       this.#bytes = input;
21 |     }
22 | 
23 |     this.#network = network ?? Network.Mainnet;
24 |   }
25 | 
26 |   get header(): number {
27 |     return this.#bytes[0];
28 |   }
29 | 
30 |   get version(): number {
31 |     return this.header & VERSION_MASK;
32 |   }
33 | 
34 |   get hasSegregatedConstants(): boolean {
35 |     return (this.header & ergoTreeHeaderFlags.constantSegregation) !== 0;
36 |   }
37 | 
38 |   get hasSize(): boolean {
39 |     return (this.header & ergoTreeHeaderFlags.sizeInclusion) !== 0;
40 |   }
41 | 
42 |   toBytes(): Uint8Array {
43 |     return this.#bytes;
44 |   }
45 | 
46 |   toHex(): HexString {
47 |     return hex.encode(this.toBytes());
48 |   }
49 | 
50 |   toAddress(network?: Network): ErgoAddress {
51 |     return ErgoAddress.fromErgoTree(this.toHex(), network ?? this.#network);
52 |   }
53 | 
54 |   encode(network?: Network): Base58String {
55 |     return this.toAddress(network).encode();
56 |   }
57 | }
58 | 


--------------------------------------------------------------------------------
/packages/core/src/models/ergoUnsignedInput.ts:
--------------------------------------------------------------------------------
 1 | import type {
 2 |   Amount,
 3 |   Box,
 4 |   PlainObjectType,
 5 |   ContextExtension,
 6 |   EIP12UnsignedInput,
 7 |   NonMandatoryRegisters,
 8 |   UnsignedInput,
 9 |   DataInput,
10 |   EIP12UnsignedDataInput
11 | } from "@fleet-sdk/common";
12 | import type { ConstantInput } from "../builder";
13 | import { ErgoBox } from "./ergoBox";
14 | 
15 | type InputBox<R extends NonMandatoryRegisters> = Box<Amount, R> & {
16 |   extension?: ContextExtension;
17 | };
18 | type ContextExtensionInput = ContextExtension<ConstantInput>;
19 | 
20 | export class ErgoUnsignedInput<
21 |   R extends NonMandatoryRegisters = NonMandatoryRegisters
22 | > extends ErgoBox<R> {
23 |   #extension?: ContextExtension;
24 | 
25 |   get extension(): ContextExtension {
26 |     return this.#extension || {};
27 |   }
28 | 
29 |   constructor(box: InputBox<R>) {
30 |     super(box);
31 |     if (box.extension) this.setContextExtension(box.extension);
32 |   }
33 | 
34 |   setContextExtension(extension: ContextExtensionInput): ErgoUnsignedInput {
35 |     const vars: ContextExtension = {};
36 |     for (const key in extension) {
37 |       const c = extension[key] as ConstantInput;
38 |       if (!c) continue;
39 | 
40 |       vars[key as unknown as keyof ContextExtension] =
41 |         typeof c === "string" ? c : c.toHex();
42 |     }
43 | 
44 |     this.#extension = vars;
45 | 
46 |     return this;
47 |   }
48 | 
49 |   /**
50 |    * @deprecated use `setContextExtension` instead.
51 |    */
52 |   setContextVars(extension: ContextExtensionInput): ErgoUnsignedInput {
53 |     return this.setContextExtension(extension);
54 |   }
55 | 
56 |   override toPlainObject(type: "EIP-12"): EIP12UnsignedInput;
57 |   override toPlainObject(type: "minimal"): UnsignedInput;
58 |   override toPlainObject(type: PlainObjectType): EIP12UnsignedInput | UnsignedInput;
59 |   override toPlainObject(type: PlainObjectType): EIP12UnsignedInput | UnsignedInput {
60 |     return { ...super.toPlainObject(type), extension: this.extension };
61 |   }
62 | 
63 |   toDataInputPlainObject(type: "EIP-12"): EIP12UnsignedDataInput;
64 |   toDataInputPlainObject(type: "minimal"): DataInput;
65 |   toDataInputPlainObject(type: PlainObjectType): EIP12UnsignedDataInput | DataInput;
66 |   toDataInputPlainObject(type: PlainObjectType): EIP12UnsignedDataInput | DataInput {
67 |     return super.toPlainObject(type);
68 |   }
69 | }
70 | 


--------------------------------------------------------------------------------
/packages/core/src/models/ergoUnsignedTransactionChain.ts:
--------------------------------------------------------------------------------
 1 | import type { EIP12UnsignedTransaction, UnsignedTransaction } from "@fleet-sdk/common";
 2 | import type { ErgoUnsignedTransaction } from "./ergoUnsignedTransaction";
 3 | 
 4 | export class ErgoUnsignedTransactionChain {
 5 |   #entryPoint: ErgoUnsignedTransaction;
 6 | 
 7 |   constructor(entryPoint: ErgoUnsignedTransaction) {
 8 |     this.#entryPoint = entryPoint;
 9 |   }
10 | 
11 |   first(): ErgoUnsignedTransaction {
12 |     return this.#entryPoint;
13 |   }
14 | 
15 |   toArray() {
16 |     let parent = this.#entryPoint;
17 |     const chain = [parent];
18 | 
19 |     while (parent.child) {
20 |       chain.push(parent.child);
21 |       parent = parent.child;
22 |     }
23 | 
24 |     return chain;
25 |   }
26 | 
27 |   toEIP12Object(): EIP12UnsignedTransaction[] {
28 |     return this.toArray().map((child) => child.toEIP12Object());
29 |   }
30 | 
31 |   toPlainObject(): UnsignedTransaction[] {
32 |     return this.toArray().map((child) => child.toPlainObject());
33 |   }
34 | }
35 | 


--------------------------------------------------------------------------------
/packages/core/src/models/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./ergoAddress";
2 | export * from "./ergoBox";
3 | export * from "./ergoUnsignedInput";
4 | export * from "./ergoUnsignedTransaction";
5 | export * from "./collections";
6 | export * from "./ergoTree";
7 | export * from "./ergoMessage";
8 | export { validateAddress } from "./utils";
9 | 


--------------------------------------------------------------------------------
/packages/core/src/models/utils.spec.ts:
--------------------------------------------------------------------------------
 1 | import { base58 } from "@fleet-sdk/crypto";
 2 | import { describe, expect, it } from "vitest";
 3 | import { ErgoMessage } from "./ergoMessage";
 4 | import { unpackAddress, validateAddress, validateUnpackedAddress } from "./utils";
 5 | 
 6 | describe("Address validation", () => {
 7 |   it("Should not validate addresses", () => {
 8 |     expect(validateAddress(ErgoMessage.fromData("hello world").encode())).to.be.true;
 9 |   });
10 | 
11 |   it("Should not validate addresses with empty body", () => {
12 |     const unpacked = unpackAddress(
13 |       base58.decode(ErgoMessage.fromData("hello world").encode())
14 |     );
15 |     unpacked.body = new Uint8Array(0);
16 |     expect(validateUnpackedAddress(unpacked)).to.be.false;
17 |   });
18 | });
19 | 


--------------------------------------------------------------------------------
/packages/core/src/models/utils.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   AddressType,
 3 |   areEqual,
 4 |   type Base58String,
 5 |   concatBytes,
 6 |   first,
 7 |   isEmpty,
 8 |   type Network
 9 | } from "@fleet-sdk/common";
10 | import { base58, blake2b256, validateEcPoint } from "@fleet-sdk/crypto";
11 | import { SigmaByteWriter } from "@fleet-sdk/serializer";
12 | 
13 | export const CHECKSUM_LENGTH = 4;
14 | export const BLAKE_256_HASH_LENGTH = 32;
15 | 
16 | export type UnpackedAddress = {
17 |   head: Uint8Array;
18 |   body: Uint8Array;
19 |   checksum: Uint8Array;
20 |   network: Network;
21 |   type: AddressType;
22 | };
23 | 
24 | export function getNetworkType(addressBytes: Uint8Array): Network {
25 |   return first(addressBytes) & 0xf0;
26 | }
27 | 
28 | export function getAddressType(addressBytes: Uint8Array): AddressType {
29 |   return first(addressBytes) & 0x0f;
30 | }
31 | 
32 | /**
33 |  * Unpacks the given bytes into an UnpackedAddress object.
34 |  *
35 |  * @param bytes - The bytes to unpack.
36 |  * @returns The UnpackedAddress object containing the unpacked data.
37 |  */
38 | export function unpackAddress(bytes: Uint8Array): UnpackedAddress {
39 |   return {
40 |     head: bytes.subarray(0, 1),
41 |     body: bytes.subarray(1, bytes.length - CHECKSUM_LENGTH),
42 |     checksum: bytes.subarray(bytes.length - CHECKSUM_LENGTH, bytes.length),
43 |     network: getNetworkType(bytes),
44 |     type: getAddressType(bytes)
45 |   };
46 | }
47 | 
48 | export function encodeAddress(
49 |   network: Network,
50 |   type: AddressType,
51 |   content: Uint8Array
52 | ): Base58String {
53 |   return new SigmaByteWriter(1 /** head */ + content.length + CHECKSUM_LENGTH)
54 |     .write(network + type)
55 |     .writeBytes(content)
56 |     .writeChecksum(CHECKSUM_LENGTH)
57 |     .encode(base58);
58 | }
59 | 
60 | export function validateUnpackedAddress(unpacked: UnpackedAddress): boolean {
61 |   const content = concatBytes(unpacked.head, unpacked.body);
62 |   if (isEmpty(unpacked.body)) return false;
63 |   if (unpacked.type === AddressType.P2PK && !validateEcPoint(unpacked.body)) return false;
64 | 
65 |   const checksum = blake2b256(content).subarray(0, CHECKSUM_LENGTH);
66 |   return areEqual(checksum, unpacked.checksum);
67 | }
68 | 
69 | /**
70 |  * Validates a Base58 encoded address.
71 |  *
72 |  * @param encodedAddress - The Base58 encoded address to validate.
73 |  * @returns A boolean indicating whether the address is valid or not.
74 |  */
75 | export function validateAddress(encodedAddress: Base58String): boolean {
76 |   return validateUnpackedAddress(unpackAddress(base58.decode(encodedAddress)));
77 | }
78 | 


--------------------------------------------------------------------------------
/packages/crypto/CHANGELOG.md:
--------------------------------------------------------------------------------
  1 | # @fleet-sdk/crypto
  2 | 
  3 | ## 0.8.2
  4 | 
  5 | ### Patch Changes
  6 | 
  7 | - 9a244b5: Add `blake2b` function
  8 | - 1b07c4a: Bump dependencies
  9 | 
 10 | ## 0.8.0
 11 | 
 12 | ### Patch Changes
 13 | 
 14 | - b2ce7aa: Upgrade external dependencies
 15 | - Updated dependencies [36adc61]
 16 |   - @fleet-sdk/common@0.8.0
 17 | 
 18 | ## 0.6.4
 19 | 
 20 | ### Patch Changes
 21 | 
 22 | - Updated dependencies [504974e]
 23 |   - @fleet-sdk/common@0.6.4
 24 | 
 25 | ## 0.5.0
 26 | 
 27 | ### Patch Changes
 28 | 
 29 | - 6ecfd2e: Add `ensureBytes()` function
 30 | 
 31 | ## 0.4.1
 32 | 
 33 | ### Patch Changes
 34 | 
 35 | - Updated dependencies [28e3467]
 36 |   - @fleet-sdk/common@0.4.1
 37 | 
 38 | ## 0.4.0
 39 | 
 40 | ### Minor Changes
 41 | 
 42 | - 70aea89: Add `bigintBE` coder
 43 | - 253d37a: Add `validateEcPoint()` function
 44 | 
 45 | ## 0.3.4
 46 | 
 47 | ### Patch Changes
 48 | 
 49 | - 9f02ca0: Fix ESM and CJS modules export
 50 | - Updated dependencies [9f02ca0]
 51 |   - @fleet-sdk/common@0.3.4
 52 | 
 53 | ## 0.3.2
 54 | 
 55 | ### Patch Changes
 56 | 
 57 | - Updated dependencies [1d6e259]
 58 | - Updated dependencies [1d6e259]
 59 |   - @fleet-sdk/common@0.3.2
 60 | 
 61 | ## 0.2.3
 62 | 
 63 | ### Patch Changes
 64 | 
 65 | - 1e0edd4: Fix missing `types` export in `package.json`
 66 | - 65d5b33: Hex encoder performance improvements.
 67 | - 514dcd2: Fix wrong Base16 hash input encoding.
 68 | - Updated dependencies [1e0edd4]
 69 |   - @fleet-sdk/common@0.2.3
 70 | 
 71 | ## 0.2.2
 72 | 
 73 | ### Patch Changes
 74 | 
 75 | - Updated dependencies [9cbd414]
 76 |   - @fleet-sdk/common@0.2.2
 77 | 
 78 | ## 0.2.1
 79 | 
 80 | ### Patch Changes
 81 | 
 82 | - edf2830: Fix module exporting.
 83 | - Updated dependencies [edf2830]
 84 |   - @fleet-sdk/common@0.2.1
 85 | 
 86 | ## 0.2.0
 87 | 
 88 | ### Minor Changes
 89 | 
 90 | - 8a13a29: Introduce `crypto` package with Ergo crypto primitives.
 91 | - 2ab9661: Add byte coders
 92 |   - `base64` - encode/decode base64 string;
 93 |   - `base58` - encode/decode base58 string;
 94 |   - `base58check` - encode/decode base58check string;
 95 |   - `hex` - encode/decode hex string;
 96 |   - `utf8` - encode/decode hex string.
 97 | - 2ab9661: Add hashing functions:
 98 |   - `blake2b256()`
 99 |   - `sha256()`
100 | 
101 | ### Patch Changes
102 | 
103 | - Updated dependencies [5a79c57]
104 | - Updated dependencies [a491ab9]
105 | - Updated dependencies [3236dd8]
106 | - Updated dependencies [9bd393b]
107 |   - @fleet-sdk/common@0.2.0
108 | 


--------------------------------------------------------------------------------
/packages/crypto/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 Nautilus Team
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/crypto/README.md:
--------------------------------------------------------------------------------
1 | # @fleet-sdk/crypto [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/crypto)](https://www.npmjs.com/package/@fleet-sdk/crypto)
2 | 
3 | Ergo blockchain crypto primitives.
4 | 


--------------------------------------------------------------------------------
/packages/crypto/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/crypto",
 3 |   "version": "0.8.2",
 4 |   "description": "Ergo blockchain crypto primitives.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "crypto"
31 |   ],
32 |   "scripts": {
33 |     "build": "tsup --config ../../tsup.config.ts"
34 |   },
35 |   "engines": {
36 |     "node": ">=18"
37 |   },
38 |   "dependencies": {
39 |     "@fleet-sdk/common": "workspace:^",
40 |     "@noble/hashes": "^1.7.1",
41 |     "@scure/base": "^1.2.4"
42 |   },
43 |   "files": [
44 |     "dist",
45 |     "!**/*.spec.*",
46 |     "!**/*.json",
47 |     "!tests",
48 |     "CHANGELOG.md",
49 |     "LICENSE",
50 |     "README.md"
51 |   ]
52 | }
53 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/bigintBE.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { bigintBE } from "./bigintBE";
 3 | 
 4 | describe("Big Endian BigInt coder", () => {
 5 |   it("Should encode Uint8Array to bigint", () => {
 6 |     expect(bigintBE.encode(Uint8Array.from([1]))).to.be.equal(1n);
 7 |     expect(bigintBE.encode(Uint8Array.from([0]))).to.be.equal(0n);
 8 |     expect(bigintBE.encode(Uint8Array.from([]))).to.be.equal(0n);
 9 |     expect(bigintBE.encode(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))).to.be.equal(
10 |       3735928559n
11 |     );
12 |   });
13 | 
14 |   it("Should decode bigint to Uint8Array", () => {
15 |     expect(bigintBE.decode(1n)).to.be.deep.equal(Uint8Array.from([1]));
16 |     expect(bigintBE.decode(0n)).to.be.deep.equal(Uint8Array.from([0]));
17 |     expect(bigintBE.decode(3735928559n)).to.be.deep.equal(
18 |       Uint8Array.from([0xde, 0xad, 0xbe, 0xef])
19 |     );
20 |   });
21 | });
22 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/bigintBE.ts:
--------------------------------------------------------------------------------
 1 | import { hex } from "@scure/base";
 2 | import type { Coder } from "../types";
 3 | 
 4 | /**
 5 |  * A coder for Big Endian  `BigInt` <> `Uint8Array` conversion..
 6 |  */
 7 | export const bigintBE: Coder<Uint8Array, bigint> = {
 8 |   /**
 9 |    * Encode a `Uint8Array` to a `BigInt`.
10 |    */
11 |   encode(data) {
12 |     const hexInput = hex.encode(data);
13 |     return BigInt(hexInput === "" ? "0" : `0x${hexInput}`);
14 |   },
15 | 
16 |   /**
17 |    * Decode a `BigInt` to a `Uint8Array`.
18 |    */
19 |   decode(data) {
20 |     const hexData = data.toString(16);
21 |     return hex.decode(hexData.length % 2 ? `0${hexData}` : hexData);
22 |   }
23 | };
24 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/hex.bench.ts:
--------------------------------------------------------------------------------
 1 | import { bytesToHex, hexToBytes } from "@noble/hashes/utils";
 2 | import { hex as scureHex } from "@scure/base";
 3 | import { bench, describe } from "vitest";
 4 | import { regularBoxes, validBoxes } from "../../../_test-vectors/mockedBoxes";
 5 | import { hex as fleetHex } from "./hex";
 6 | 
 7 | const hexString = [...regularBoxes, ...validBoxes].map((x) => x.ergoTree).join("");
 8 | const bytes = hexToBytes(hexString);
 9 | 
10 | describe("Decode hex to bytes", () => {
11 |   bench("@noble/hashes implementation", () => {
12 |     hexToBytes(hexString);
13 |   });
14 | 
15 |   bench("@scure/base implementation", () => {
16 |     scureHex.decode(hexString);
17 |   });
18 | 
19 |   bench("@fleet-sdk/crypto implementation", () => {
20 |     fleetHex.decode(hexString);
21 |   });
22 | });
23 | 
24 | describe("Encode bytes to hex", () => {
25 |   bench("@noble/hashes implementation", () => {
26 |     bytesToHex(bytes);
27 |   });
28 | 
29 |   bench("@scure/base implementation", () => {
30 |     scureHex.encode(bytes);
31 |   });
32 | 
33 |   bench("@fleet-sdk/crypto implementation", () => {
34 |     fleetHex.encode(bytes);
35 |   });
36 | });
37 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/hex.spec.ts:
--------------------------------------------------------------------------------
 1 | import fc from "fast-check";
 2 | import { describe, expect, it, test } from "vitest";
 3 | import { hex } from "./hex";
 4 | 
 5 | const ui8a = (bytes: number[]) => Uint8Array.from(bytes);
 6 | const paddedHexArb = fc
 7 |   .mixedCase(fc.hexaString({ size: "medium" }))
 8 |   .map((v) => (v.length % 2 ? v.padStart(v.length + 1, "0") : v));
 9 | 
10 | describe("Fuzzy hex <-> bytes roundtrip", () => {
11 |   test("byte -> hex -> byte", () => {
12 |     fc.assert(
13 |       fc.property(fc.uint8Array({ size: "medium" }), (bytes) => {
14 |         expect(hex.decode(hex.encode(bytes))).to.be.deep.equal(bytes);
15 |       })
16 |     );
17 |   });
18 | 
19 |   test("hex -> byte -> hex", () => {
20 |     fc.assert(
21 |       fc.property(paddedHexArb, (hexString) => {
22 |         expect(hex.encode(hex.decode(hexString))).to.be.equal(hexString.toLowerCase());
23 |       })
24 |     );
25 |   });
26 | });
27 | 
28 | describe("Hex <-> Bytes serialization", () => {
29 |   it("Should convert hex to bytes", () => {
30 |     expect(hex.decode("deadbeef")).to.be.deep.equal(ui8a([0xde, 0xad, 0xbe, 0xef]));
31 |     expect(hex.decode("DEADBEEF")).to.be.deep.equal(ui8a([0xde, 0xad, 0xbe, 0xef]));
32 |     expect(hex.decode("deadBEEF")).to.be.deep.equal(ui8a([0xde, 0xad, 0xbe, 0xef]));
33 |     expect(hex.decode("cafe123456")).to.be.deep.equal(
34 |       ui8a([0xca, 0xfe, 0x12, 0x34, 0x56])
35 |     );
36 |     expect(hex.decode("CAFE123456")).to.be.deep.equal(
37 |       ui8a([0xca, 0xfe, 0x12, 0x34, 0x56])
38 |     );
39 |   });
40 | 
41 |   it("Should convert bytes to hex", () => {
42 |     expect(hex.encode(ui8a([0xde, 0xad, 0xbe, 0xef]))).to.be.equal("deadbeef");
43 |     expect(hex.encode(ui8a([0xca, 0xfe, 0x12, 0x34, 0x56]))).to.be.equal("cafe123456");
44 |   });
45 | 
46 |   it("Should roundtrip", () => {
47 |     expect(hex.encode(hex.decode("deadbeef"))).to.be.deep.equal("deadbeef");
48 |     expect(hex.decode(hex.encode(ui8a([0xca, 0xfe, 0x12, 0x34, 0x56])))).to.be.deep.equal(
49 |       ui8a([0xca, 0xfe, 0x12, 0x34, 0x56])
50 |     );
51 |   });
52 | 
53 |   test("Hex to byte with invalid inputs", () => {
54 |     expect(() => hex.decode("non hex string")).to.throw("Invalid byte sequence");
55 |     expect(() => hex.decode("0643d437ee7")).to.throw("Invalid hex padding");
56 |     expect(() => hex.decode(1 as unknown as string)).to.throw(
57 |       "Expected an object of type 'string', got 'number'."
58 |     );
59 |   });
60 | 
61 |   test("Bytes to hex with invalid inputs", () => {
62 |     const invalidBytes = [1, -2, 2, -55] as unknown as Uint8Array;
63 |     expect(() => hex.encode(invalidBytes)).to.throw(
64 |       "Expected an instance of 'Uint8Array', got 'Array'."
65 |     );
66 |   });
67 | });
68 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/hex.ts:
--------------------------------------------------------------------------------
 1 | import { assert, assertInstanceOf, assertTypeOf } from "@fleet-sdk/common";
 2 | import type { BytesCoder } from "../types";
 3 | 
 4 | const HEXES = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
 5 | 
 6 | const HexChar = {
 7 |   ZERO: 48, // 0
 8 |   NINE: 57, // 9
 9 |   A_UP: 65, // A
10 |   F_UP: 70, // F
11 |   A_LO: 97, // a
12 |   F_LO: 102 // f
13 | } as const;
14 | 
15 | function bytesToHex(bytes: Uint8Array): string {
16 |   assertInstanceOf(bytes, Uint8Array);
17 | 
18 |   let hex = "";
19 |   for (let i = 0, len = bytes.length; i < len; i++) {
20 |     hex += HEXES[bytes[i]];
21 |   }
22 | 
23 |   return hex;
24 | }
25 | 
26 | function hexToBytes(hex: string): Uint8Array {
27 |   assertTypeOf(hex, "string");
28 |   assert(hex.length % 2 === 0, "Invalid hex padding.");
29 | 
30 |   const len = hex.length / 2;
31 |   const bytes = new Uint8Array(len);
32 |   for (let i = 0, j = 0; i < len; i++) {
33 |     const n1 = charCodeToBase16(hex.charCodeAt(j++));
34 |     const n2 = charCodeToBase16(hex.charCodeAt(j++));
35 |     bytes[i] = n1 * 16 + n2;
36 |   }
37 | 
38 |   return bytes;
39 | }
40 | 
41 | function charCodeToBase16(char: number) {
42 |   if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;
43 |   if (char >= HexChar.A_UP && char <= HexChar.F_UP) return char - (HexChar.A_UP - 10);
44 |   if (char >= HexChar.A_LO && char <= HexChar.F_LO) return char - (HexChar.A_LO - 10);
45 | 
46 |   throw new Error("Invalid byte sequence.");
47 | }
48 | 
49 | export const hex: BytesCoder = {
50 |   encode: bytesToHex,
51 |   decode: hexToBytes
52 | };
53 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/index.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, test } from "vitest";
 2 | import { base58, base58check, base64, utf8 } from ".";
 3 | 
 4 | describe("Coders smoke tests", () => {
 5 |   test("base64 coder roundtrip", () => {
 6 |     const decodedBase64 = utf8.decode("this is a base64 encoded string");
 7 |     const encodedBase64 = "dGhpcyBpcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZw==";
 8 | 
 9 |     expect(base64.encode(decodedBase64)).to.be.equal(encodedBase64);
10 |     expect(base64.decode(encodedBase64)).to.be.deep.equal(decodedBase64);
11 |   });
12 | 
13 |   test("base58 coder roundtrip", () => {
14 |     const decodedBase58 = utf8.decode("this is a base58 encoded string");
15 |     const encodedBase58 = "2mxCXDZDHgWsZCCCUBhmanjEeEFPM5dg8FVb659iiJa";
16 | 
17 |     expect(base58.encode(decodedBase58)).to.be.equal(encodedBase58);
18 |     expect(base58.decode(encodedBase58)).to.be.deep.equal(decodedBase58);
19 |   });
20 | 
21 |   test("base58check coder roundtrip", () => {
22 |     const decodedBase58check = utf8.decode("this is a base58check encoded string");
23 |     const encodedBase58check = "6nURSRrD1s933Ruwq4Gi9XzULMhuRQbX1mYrnY2jknX9pW67uKbADDk";
24 | 
25 |     expect(base58check.encode(decodedBase58check)).to.be.equal(encodedBase58check);
26 |     expect(base58check.decode(encodedBase58check)).to.be.deep.equal(decodedBase58check);
27 |   });
28 | });
29 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/index.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   base58check as base58checkCoder,
 3 |   base58 as base58Coder,
 4 |   base64 as base64Coder
 5 | } from "@scure/base";
 6 | import { sha256 } from "../hashes";
 7 | import type { BytesCoder } from "../types";
 8 | 
 9 | export const base58check = base58checkCoder(sha256);
10 | export const base58 = base58Coder as BytesCoder;
11 | export const base64 = base64Coder as BytesCoder;
12 | 
13 | export { hex } from "./hex";
14 | export { utf8 } from "./utf8";
15 | export { bigintBE } from "./bigintBE";
16 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/utf8.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it, test } from "vitest";
 2 | import { utf8 } from "./utf8";
 3 | 
 4 | describe("UTF-8 <> bytes serialization", () => {
 5 |   it("Should roundtrip", () => {
 6 |     expect(utf8.encode(utf8.decode("this is a regular string"))).to.be.equal(
 7 |       "this is a regular string"
 8 |     );
 9 |   });
10 | 
11 |   test("utf8 to bytes with invalid inputs", () => {
12 |     const notAString = true as unknown as string;
13 |     expect(() => utf8.decode(notAString)).to.throw(
14 |       "Expected an object of type 'string', got 'boolean'."
15 |     );
16 |   });
17 | 
18 |   test("bytes to utf8 with invalid inputs", () => {
19 |     const invalidBytes = {} as unknown as Uint8Array;
20 |     expect(() => utf8.encode(invalidBytes)).to.throw(
21 |       "Expected an instance of 'Uint8Array', got 'Object'."
22 |     );
23 |   });
24 | });
25 | 


--------------------------------------------------------------------------------
/packages/crypto/src/coders/utf8.ts:
--------------------------------------------------------------------------------
 1 | import { assertInstanceOf, assertTypeOf } from "@fleet-sdk/common";
 2 | import type { BytesCoder } from "../types";
 3 | 
 4 | function bytesToUtf8(bytes: Uint8Array): string {
 5 |   assertInstanceOf(bytes, Uint8Array);
 6 | 
 7 |   return new TextDecoder().decode(bytes);
 8 | }
 9 | 
10 | function utf8ToBytes(str: string): Uint8Array {
11 |   assertTypeOf(str, "string");
12 | 
13 |   return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
14 | }
15 | 
16 | export const utf8: BytesCoder = {
17 |   encode: bytesToUtf8,
18 |   decode: utf8ToBytes
19 | };
20 | 


--------------------------------------------------------------------------------
/packages/crypto/src/ecpoint.spec.ts:
--------------------------------------------------------------------------------
  1 | import { describe, expect, test } from "vitest";
  2 | import { hex } from "./coders/hex";
  3 | import { validateEcPoint } from "./ecpoint";
  4 | 
  5 | const testVectors = [
  6 |   {
  7 |     name: "valid compressed, positive Y coordinate",
  8 |     point: hex.decode(
  9 |       "0289b72d85b8a72b0a53960bafddadb74a149c6c1785d2bb46c244401e61d80b4d"
 10 |     ),
 11 |     valid: true
 12 |   },
 13 |   {
 14 |     name: "valid compressed, negative Y coordinate",
 15 |     point: hex.decode(
 16 |       "0376b32d0bb20f15004649946db5679adce657bef77c487add608115ce8050b16e"
 17 |     ),
 18 |     valid: true
 19 |   },
 20 |   {
 21 |     name: "invalid compressed",
 22 |     point: hex.decode(
 23 |       "0476b32d0bb20f15004649946db5679adce657bef77c487add608115ce8050b16e"
 24 |     ),
 25 |     valid: false
 26 |   },
 27 |   {
 28 |     name: "invalid compressed",
 29 |     point: hex.decode(
 30 |       "0576b32d0bb20f15004649946db5679adce657bef77c487add608115ce8050b16e"
 31 |     ),
 32 |     valid: false
 33 |   },
 34 |   {
 35 |     name: "valid uncompressed",
 36 |     point: hex.decode(
 37 |       "04784781bfad60e7da448912726c463736acdbc1864cec9ea3bfb22b3e974aa2bc579b466b40775367863186a7d9557be1b0f99ea55cff204019eba6539abead7b"
 38 |     ),
 39 |     valid: true
 40 |   },
 41 |   {
 42 |     name: "valid uncompressed",
 43 |     point: hex.decode(
 44 |       "04b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a87378ec38ff91d43e8c2092ebda601780485263da089465619e0358a5c1be7ac91f4"
 45 |     ),
 46 |     valid: true
 47 |   },
 48 |   {
 49 |     name: "invalid uncompressed",
 50 |     point: hex.decode(
 51 |       "03b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a87378ec38ff91d43e8c2092ebda601780485263da089465619e0358a5c1be7ac91f4"
 52 |     ),
 53 |     valid: false
 54 |   },
 55 |   {
 56 |     name: "length > 65",
 57 |     point: hex.decode(
 58 |       "04784781bfad60e7da448912726c463736acdbc1864cec9ea3bfb22b3e974aa2bc579b466b40775367863186a7d9557be1b0f99ea55cff204019eba6539abead7b9abead7b"
 59 |     ),
 60 |     valid: false
 61 |   },
 62 |   {
 63 |     name: "length > 33 and < 65",
 64 |     point: hex.decode(
 65 |       "0289b72d85b8a72b0a53960bafddadb74a149c6c1785d2bb46c244401e61d80b4d4e"
 66 |     ),
 67 |     valid: false
 68 |   },
 69 |   {
 70 |     name: "length < 33",
 71 |     point: hex.decode("020102030405060708"),
 72 |     valid: false
 73 |   },
 74 |   {
 75 |     name: "length < 33, valid positive head",
 76 |     point: hex.decode("02"),
 77 |     valid: false
 78 |   },
 79 |   {
 80 |     name: "length < 33, valid negative head",
 81 |     point: hex.decode("03"),
 82 |     valid: false
 83 |   },
 84 |   {
 85 |     name: "length < 33, valid negative head",
 86 |     point: hex.decode("04"),
 87 |     valid: false
 88 |   },
 89 |   { name: "empty", point: hex.decode(""), valid: false },
 90 |   {
 91 |     name: "undefined",
 92 |     point: undefined as unknown as Uint8Array,
 93 |     valid: false
 94 |   }
 95 | ];
 96 | 
 97 | describe("Compressed ECPoint validation", () => {
 98 |   test.each(testVectors)("Should validate compressed ECPoint: $name", (tv) => {
 99 |     expect(validateEcPoint(tv.point)).to.be.equal(tv.valid);
100 |   });
101 | });
102 | 


--------------------------------------------------------------------------------
/packages/crypto/src/ecpoint.ts:
--------------------------------------------------------------------------------
 1 | import { isEmpty } from "@fleet-sdk/common";
 2 | 
 3 | /**
 4 |  * EC point type
 5 |  */
 6 | enum EcPointType {
 7 |   /**
 8 |    * Compressed, positive Y coordinate
 9 |    */
10 |   Compressed = 0x02,
11 |   /**
12 |    * Compressed, negative Y coordinate
13 |    */
14 |   CompressedOdd = 0x03,
15 |   /**
16 |    * Uncompressed
17 |    */
18 |   Uncompressed = 0x04
19 | }
20 | 
21 | /**
22 |  * Validate Elliptic Curve point
23 |  *
24 |  * @param pointBytes EC point bytes
25 |  * @returns True if the point is valid
26 |  */
27 | export function validateEcPoint(pointBytes: Uint8Array) {
28 |   if (isEmpty(pointBytes)) return false;
29 | 
30 |   switch (pointBytes[0]) {
31 |     case EcPointType.Compressed:
32 |     case EcPointType.CompressedOdd:
33 |       return pointBytes.length === 33;
34 |     case EcPointType.Uncompressed:
35 |       return pointBytes.length === 65;
36 |     default:
37 |       return false;
38 |   }
39 | }
40 | 


--------------------------------------------------------------------------------
/packages/crypto/src/hashes.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { hex, utf8 } from "./coders";
 3 | import { blake2b, blake2b256, sha256 } from "./hashes";
 4 | import { randomBytes } from "@noble/hashes/utils";
 5 | 
 6 | describe("Hashes smoke tests", () => {
 7 |   it("Should hash message using BLAKE2b256", () => {
 8 |     const msg = utf8.decode("blake2b256");
 9 |     expect(blake2b256(msg)).to.be.deep.equal(
10 |       hex.decode("eb95e6932cedac15db722fcdb0cfd21437f94690339a716251fad2f89842ea8b")
11 |     );
12 |   });
13 | 
14 |   it("Should hash message using BLAKE2b with parameters", () => {
15 |     const xpk = utf8.decode(
16 |       "0488b21e000000000000000000b345a673afdeb85091c35d02083035f6e0ca284b1846223b23b566c4070a0cec02a3ad1969b60e85426791b75eccf038e6105c3afab8167af7eb6b73e709b81882"
17 |     );
18 | 
19 |     expect(
20 |       hex.encode(
21 |         blake2b(xpk, {
22 |           dkLen: 64,
23 |           personalization: utf8.decode("wallets checksum")
24 |         })
25 |       )
26 |     ).to.be.equal(
27 |       "5d33031ea3bbba9d3332559b1dafd8612683092f535273a4c15ffa103ffa3fc11f7b6992f5a034b3c8dd30f6f103b24e500c44ba4cff2e5c7f6e3e2eb124cd32"
28 |     );
29 | 
30 |     expect(
31 |       hex.encode(
32 |         blake2b(xpk, {
33 |           dkLen: 64,
34 |           personalization: hex.encode(utf8.decode("wallets checksum")),
35 |           salt: hex.decode("d877f8df03fd687ab7c0052e3ce88372")
36 |         })
37 |       )
38 |     ).to.be.equal(
39 |       "f2afda2f44c2f5dd85d0e10e6d42b7c9220a1c8cfb0b25b8d7e554a0be570c39d8d299553fa8b2ecd56e4dc6eb240df93d67640558761df339c04638f2513d75"
40 |     );
41 | 
42 |     expect(
43 |       hex.encode(
44 |         blake2b(xpk, {
45 |           dkLen: 64,
46 |           personalization: hex.encode(utf8.decode("wallets checksum")),
47 |           key: "6a9059057f259d733766f6b32081b66c",
48 |           salt: "d877f8df03fd687ab7c0052e3ce88372"
49 |         })
50 |       )
51 |     ).to.be.equal(
52 |       "48cc44fc205ce4932349ad81156b65477029392cb9fd4d6b05519a9a4c4f2485b9902a59ace75bc9215430f226f411ca90e02a34761980ee557ac2b55cc01282"
53 |     );
54 |   });
55 | 
56 |   it("Should handle strings as hex", () => {
57 |     const msg = randomBytes(32);
58 |     const key = randomBytes(32);
59 |     const salt = randomBytes(16);
60 |     const personalization = randomBytes(16);
61 | 
62 |     expect(blake2b(msg, { key, salt, personalization })).to.be.deep.equal(
63 |       blake2b(msg, {
64 |         key: hex.encode(key),
65 |         salt: hex.encode(salt),
66 |         personalization: hex.encode(personalization)
67 |       })
68 |     );
69 |   });
70 | 
71 |   it("Should have the same result regardless input format", () => {
72 |     const byte = Uint8Array.from([0xde, 0xad, 0xbe, 0xef]);
73 |     const hex = "deadbeef";
74 | 
75 |     expect(blake2b256(byte)).to.be.deep.equal(blake2b256(hex));
76 |     expect(sha256(byte)).to.be.deep.equal(sha256(hex));
77 |   });
78 | 
79 |   it("Should hash message using sha256", () => {
80 |     expect(sha256(utf8.decode("sha256"))).to.be.deep.equal(
81 |       hex.decode("5d5b09f6dcb2d53a5fffc60c4ac0d55fabdf556069d6631545f42aa6e3500f2e")
82 |     );
83 |   });
84 | });
85 | 


--------------------------------------------------------------------------------
/packages/crypto/src/hashes.ts:
--------------------------------------------------------------------------------
 1 | import { blake2b as _blake2b } from "@noble/hashes/blake2b";
 2 | import { sha256 as _sha256 } from "@noble/hashes/sha256";
 3 | import { hex } from "./coders";
 4 | import type { ByteInput } from "./types";
 5 | 
 6 | export type Blake2b256Options = {
 7 |   key?: ByteInput;
 8 |   salt?: ByteInput;
 9 |   personalization?: ByteInput;
10 | };
11 | 
12 | export type Blake2bOptions = Blake2b256Options & {
13 |   dkLen?: number;
14 | };
15 | 
16 | export function ensureBytes(input: ByteInput): Uint8Array {
17 |   return typeof input === "string" ? hex.decode(input) : input;
18 | }
19 | 
20 | export function blake2b(message: ByteInput, options?: Blake2bOptions): Uint8Array {
21 |   if (options?.key) options.key = ensureBytes(options.key);
22 |   if (options?.salt) options.salt = ensureBytes(options.salt);
23 |   if (options?.personalization)
24 |     options.personalization = ensureBytes(options.personalization);
25 | 
26 |   return _blake2b(ensureBytes(message), options);
27 | }
28 | 
29 | export function blake2b256(message: ByteInput, options?: Blake2b256Options): Uint8Array {
30 |   return blake2b(ensureBytes(message), { dkLen: 32, ...options });
31 | }
32 | 
33 | export function sha256(message: ByteInput): Uint8Array {
34 |   return _sha256(ensureBytes(message));
35 | }
36 | 


--------------------------------------------------------------------------------
/packages/crypto/src/index.ts:
--------------------------------------------------------------------------------
 1 | import { randomBytes as nobleRandomBytes } from "@noble/hashes/utils";
 2 | 
 3 | /**
 4 |  * Secure PRNG from "@noble/hashes". Uses crypto.getRandomValues, which defers to OS.
 5 |  */
 6 | export const randomBytes = nobleRandomBytes as (bytesLength?: number) => Uint8Array;
 7 | 
 8 | export * from "./hashes";
 9 | export * from "./types";
10 | export * from "./coders";
11 | export * from "./ecpoint";
12 | 


--------------------------------------------------------------------------------
/packages/crypto/src/types.ts:
--------------------------------------------------------------------------------
 1 | import type { HexString } from "@fleet-sdk/common";
 2 | 
 3 | export type ByteInput = Uint8Array | HexString;
 4 | 
 5 | export interface Coder<F, T> {
 6 |   encode(decoded: F): T;
 7 |   decode(encoded: T): F;
 8 | }
 9 | 
10 | export interface BytesCoder extends Coder<Uint8Array, string> {
11 |   /**
12 |    * Encodes an array of bytes to a string
13 |    */
14 |   encode: (data: Uint8Array) => string;
15 |   /**
16 |    * Decodes a string to an array of bytes
17 |    */
18 |   decode: (str: string) => Uint8Array;
19 | }
20 | 


--------------------------------------------------------------------------------
/packages/mock-chain/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2023 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/mock-chain/README.md:
--------------------------------------------------------------------------------
1 | # @fleet-sdk/mock-chain [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/mock-chain)](https://www.npmjs.com/package/@fleet-sdk/mock-chain)
2 | 
3 | Mock chain for Ergo Smart Contracts unit testing.
4 | 


--------------------------------------------------------------------------------
/packages/mock-chain/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/mock-chain",
 3 |   "version": "0.8.2",
 4 |   "description": "Mock chain for Ergo Smart Contracts testing.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "transactions",
31 |     "serialization",
32 |     "tests"
33 |   ],
34 |   "scripts": {
35 |     "build": "tsup --config ../../tsup.config.ts"
36 |   },
37 |   "dependencies": {
38 |     "@fleet-sdk/common": "workspace:^",
39 |     "@fleet-sdk/core": "workspace:^",
40 |     "@fleet-sdk/crypto": "workspace:^",
41 |     "@fleet-sdk/serializer": "workspace:^",
42 |     "@fleet-sdk/wallet": "workspace:^",
43 |     "diff": "^7.0.0",
44 |     "picocolors": "^1.1.1",
45 |     "sigmastate-js": "0.4.6"
46 |   },
47 |   "engines": {
48 |     "node": ">=10"
49 |   },
50 |   "files": [
51 |     "dist",
52 |     "!**/*.spec.*",
53 |     "!**/*.json",
54 |     "!tests",
55 |     "CHANGELOG.md",
56 |     "LICENSE",
57 |     "README.md"
58 |   ]
59 | }
60 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/execution.spec.ts:
--------------------------------------------------------------------------------
 1 | import { TransactionBuilder } from "@fleet-sdk/core";
 2 | import type { ErgoHDKey } from "@fleet-sdk/wallet";
 3 | import { regularBoxes } from "_test-vectors";
 4 | import { describe, expect, it } from "vitest";
 5 | import { execute } from "./execution";
 6 | import { MockChain } from "./mockChain";
 7 | import { mockUTxO } from "./objectMocking";
 8 | import { KeyedMockChainParty } from "./party";
 9 | 
10 | describe("Transaction executor", () => {
11 |   const chain = new MockChain();
12 | 
13 |   it("Should not execute transaction, invalid private key", () => {
14 |     const bob = new KeyedMockChainParty(chain, "bob");
15 |     const unsigned = new TransactionBuilder(1032850)
16 |       .from(regularBoxes)
17 |       .sendChangeTo("9hq9HfNKnK1GYHo8fobgDanuMMDnawB9BPw5tWTga3H91tpnTga")
18 |       .payMinFee()
19 |       .build();
20 | 
21 |     expect(bob.key).not.to.be.undefined;
22 |     const bobKey = bob.key;
23 |     expect(() => execute(unsigned, [bobKey])).not.to.throw();
24 |     expect(execute(unsigned, [bobKey])).to.contain({ success: false });
25 |   });
26 | 
27 |   it("Should throw if private key is missing", () => {
28 |     const key = new KeyedMockChainParty(chain, "bob").key.wipePrivateData() as ErgoHDKey;
29 |     const unsigned = new TransactionBuilder(1032850)
30 |       .from(regularBoxes)
31 |       .sendChangeTo("9hq9HfNKnK1GYHo8fobgDanuMMDnawB9BPw5tWTga3H91tpnTga")
32 |       .payMinFee()
33 |       .build();
34 | 
35 |     expect(key.isNeutered()).to.be.true;
36 |     expect(() => execute(unsigned, [key])).to.throw();
37 |   });
38 | 
39 |   it("Should not execute transaction", () => {
40 |     const bob = new KeyedMockChainParty(chain, "bob");
41 |     const input = mockUTxO({
42 |       ergoTree: bob.address.ergoTree,
43 |       value: 10000000n,
44 |       assets: [],
45 |       creationHeight: 10328490,
46 |       additionalRegisters: {}
47 |     });
48 | 
49 |     const unsigned = new TransactionBuilder(1032850)
50 |       .from(input)
51 |       .sendChangeTo("9hq9HfNKnK1GYHo8fobgDanuMMDnawB9BPw5tWTga3H91tpnTga")
52 |       .payMinFee()
53 |       .build();
54 | 
55 |     expect(bob.key).not.to.be.undefined;
56 |     const bobKey = bob.key as ErgoHDKey;
57 |     expect(execute(unsigned, [bobKey])).to.contain({ success: true });
58 |   });
59 | });
60 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/execution.ts:
--------------------------------------------------------------------------------
 1 | import { ensureDefaults, Network } from "@fleet-sdk/common";
 2 | import type { ErgoUnsignedTransaction } from "@fleet-sdk/core";
 3 | import { bigintBE, hex } from "@fleet-sdk/crypto";
 4 | import type { ErgoHDKey } from "@fleet-sdk/wallet";
 5 | import {
 6 |   type BlockchainParameters,
 7 |   type BlockchainStateContext,
 8 |   ProverBuilder$
 9 | } from "sigmastate-js/main";
10 | import { mockBlockchainStateContext } from "./objectMocking";
11 | 
12 | /**
13 |  * blockchain parameters at height 1283632
14 |  */
15 | export const BLOCKCHAIN_PARAMETERS: BlockchainParameters = {
16 |   storageFeeFactor: 1250000,
17 |   minValuePerByte: 360,
18 |   maxBlockSize: 1271009,
19 |   tokenAccessCost: 100,
20 |   inputCost: 2407,
21 |   dataInputCost: 100,
22 |   outputCost: 197,
23 |   maxBlockCost: 8001091,
24 |   blockVersion: 3
25 | };
26 | 
27 | export type TransactionExecutionResult = {
28 |   success: boolean;
29 |   reason?: string;
30 | };
31 | 
32 | export type ExecutionParameters = {
33 |   context?: BlockchainStateContext;
34 |   parameters?: BlockchainParameters;
35 |   network?: Network;
36 |   baseCost?: number;
37 | };
38 | 
39 | export function execute(
40 |   unsigned: ErgoUnsignedTransaction,
41 |   keys: ErgoHDKey[],
42 |   parameters?: ExecutionParameters
43 | ): TransactionExecutionResult {
44 |   for (const key of keys) {
45 |     if (!key.hasPrivateKey()) {
46 |       throw new Error(
47 |         `ErgoHDKey '${hex.encode(key.publicKey)}' must have a private key.`
48 |       );
49 |     }
50 |   }
51 | 
52 |   const eip12Tx = unsigned.toEIP12Object();
53 |   const params = ensureDefaults(parameters, {
54 |     context: mockBlockchainStateContext(),
55 |     parameters: BLOCKCHAIN_PARAMETERS,
56 |     network: Network.Mainnet,
57 |     baseCost: 0
58 |   });
59 | 
60 |   try {
61 |     const builder = ProverBuilder$.create(params.parameters, params.network);
62 |     for (const key of keys) {
63 |       builder.withDLogSecret(bigintBE.encode(key.privateKey as Uint8Array));
64 |     }
65 |     const prover = builder.build();
66 | 
67 |     const reducedTx = prover.reduce(
68 |       params.context,
69 |       eip12Tx,
70 |       eip12Tx.inputs,
71 |       eip12Tx.dataInputs,
72 |       unsigned.burning.tokens,
73 |       params.baseCost
74 |     );
75 | 
76 |     prover.signReduced(reducedTx);
77 | 
78 |     return { success: true };
79 |   } catch (e) {
80 |     return { success: false, reason: (e as Error).message };
81 |   }
82 | }
83 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./execution";
2 | export * from "./mockChain";
3 | export * from "./party";
4 | export * from "./objectMocking";
5 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/mockUtxoCollection.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   type Amount,
 3 |   type Box,
 4 |   type BoxCandidate,
 5 |   type BoxId,
 6 |   Collection,
 7 |   ensureUTxOBigInt,
 8 |   isUndefined,
 9 |   type OneOrMore
10 | } from "@fleet-sdk/common";
11 | import { isDefined } from "@fleet-sdk/common";
12 | import { DuplicateInputError, NotFoundError } from "@fleet-sdk/core";
13 | import { mockUTxO } from "./objectMocking";
14 | import type { MockUTxOInput } from "./party/mockChainParty";
15 | 
16 | function isUTxOCandidate(
17 |   candidate: BoxCandidate<Amount> | Box<Amount>
18 | ): candidate is BoxCandidate<Amount> {
19 |   return isUndefined(candidate.boxId);
20 | }
21 | 
22 | export class MockUTxOCollection extends Collection<Box<bigint>, MockUTxOInput> {
23 |   constructor();
24 |   constructor(box: Box<Amount>);
25 |   constructor(boxes: Box<Amount>[]);
26 |   constructor(boxes?: OneOrMore<Box<Amount>>) {
27 |     super();
28 | 
29 |     if (isDefined(boxes)) {
30 |       this.add(boxes);
31 |     }
32 |   }
33 | 
34 |   protected override _map(utxo: BoxCandidate<Amount> | Box<Amount>): Box<bigint> {
35 |     if (isUTxOCandidate(utxo)) {
36 |       return mockUTxO(ensureUTxOBigInt(utxo));
37 |     }
38 | 
39 |     return ensureUTxOBigInt(utxo);
40 |   }
41 | 
42 |   protected override _addOne(utxo: Box<Amount>): number {
43 |     if (this._items.some((item) => item.boxId === utxo.boxId)) {
44 |       throw new DuplicateInputError(utxo.boxId);
45 |     }
46 | 
47 |     return super._addOne(utxo);
48 |   }
49 | 
50 |   public clear() {
51 |     this._items.length = 0;
52 |   }
53 | 
54 |   public remove(boxId: BoxId): number;
55 |   public remove(index: number): number;
56 |   public remove(boxIdOrIndex: BoxId | number): number {
57 |     let index = -1;
58 |     if (typeof boxIdOrIndex === "number") {
59 |       if (this._isIndexOutOfBounds(boxIdOrIndex)) {
60 |         throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);
61 |       }
62 | 
63 |       index = boxIdOrIndex;
64 |     } else {
65 |       index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);
66 | 
67 |       if (this._isIndexOutOfBounds(index)) {
68 |         throw new NotFoundError(
69 |           "The UTxO you are trying to remove is not present in the UTxOs collection."
70 |         );
71 |       }
72 |     }
73 | 
74 |     this._items.splice(index, 1);
75 | 
76 |     return this.length;
77 |   }
78 | 
79 |   public some(predicate: (item: Box<bigint>) => unknown): boolean {
80 |     return this._items.some(predicate);
81 |   }
82 | 
83 |   public exists(boxId: string): boolean {
84 |     return this._items.some((x) => x.boxId === boxId);
85 |   }
86 | }
87 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/party/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./mockChainParty";
2 | export * from "./keyedMockChainParty";
3 | export * from "./nonKeyedMockChainParty";
4 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/party/keyedMockChainParty.spec.ts:
--------------------------------------------------------------------------------
 1 | import { ErgoBox, SAFE_MIN_BOX_VALUE } from "@fleet-sdk/core";
 2 | import { regularBoxes } from "_test-vectors";
 3 | import { describe, expect, it, vi } from "vitest";
 4 | import { MockChain } from "../mockChain";
 5 | import { KeyedMockChainParty } from "./keyedMockChainParty";
 6 | 
 7 | describe("Keyed mock chain party", () => {
 8 |   const chain = new MockChain();
 9 | 
10 |   it("Should create a keyed instance", () => {
11 |     const namedParty = new KeyedMockChainParty(chain, "bob");
12 | 
13 |     expect(namedParty.name).to.be.equal("bob");
14 |     expect(namedParty.utxos).to.have.length(0);
15 |     expect(namedParty.key).not.to.be.undefined;
16 |     expect(namedParty.address).to.be.equal(namedParty.key?.address);
17 |     expect(namedParty.ergoTree).to.be.equal(namedParty.key?.address.ergoTree);
18 |     expect(namedParty.chain).to.be.equal(chain);
19 | 
20 |     const unnamedParty = new KeyedMockChainParty(chain);
21 |     expect(unnamedParty.name).to.be.equal(unnamedParty.address.encode());
22 |   });
23 | 
24 |   it("Should add UTxOs directly", () => {
25 |     const party = new KeyedMockChainParty(chain, "bob");
26 |     party.addUTxOs(regularBoxes);
27 | 
28 |     expect(party.utxos).to.have.length(regularBoxes.length);
29 |   });
30 | 
31 |   it("Should add UTxOs directly using withUTxOs syntax sugar", () => {
32 |     const party = new KeyedMockChainParty(chain, "bob");
33 |     const addUTxOsSpy = vi.spyOn(party, "addUTxOs");
34 | 
35 |     party.withUTxOs(regularBoxes);
36 | 
37 |     expect(party.key).not.to.be.undefined;
38 |     expect(party.utxos).to.have.length(regularBoxes.length);
39 |     expect(addUTxOsSpy).toHaveBeenCalledTimes(1);
40 |     expect(addUTxOsSpy).toHaveBeenCalledWith(regularBoxes);
41 |   });
42 | 
43 |   it("Should add balance", () => {
44 |     const party = new KeyedMockChainParty(chain, "bob");
45 |     party.addBalance({ nanoergs: "10000000000" });
46 | 
47 |     expect(party.utxos).to.have.length(1);
48 |     expect(party.utxos.at(0)).to.deep.contain({
49 |       value: 10000000000n,
50 |       assets: []
51 |     });
52 |     expect(ErgoBox.validate(party.utxos.at(0))).to.be.true;
53 | 
54 |     const sigUsd = {
55 |       tokenId: "03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04",
56 |       amount: 200n
57 |     };
58 | 
59 |     party.addBalance({
60 |       tokens: [sigUsd]
61 |     });
62 | 
63 |     expect(party.utxos.at(1)).to.deep.contain({
64 |       value: SAFE_MIN_BOX_VALUE, // if nanoergs is omitted then SAFE_MIN_BOX_VALUE is added
65 |       assets: [sigUsd]
66 |     });
67 | 
68 |     expect(party.balance).to.be.deep.equal({
69 |       nanoergs: 10000000000n + SAFE_MIN_BOX_VALUE,
70 |       tokens: [sigUsd]
71 |     });
72 |     expect(ErgoBox.validate(party.utxos.at(1))).to.be.true;
73 |   });
74 | 
75 |   it("Should add UTxOs balance using withBalance syntax sugar", () => {
76 |     const party = new KeyedMockChainParty(chain, "bob");
77 |     const addBalanceSpy = vi.spyOn(party, "addBalance");
78 | 
79 |     party.withBalance({ nanoergs: "10000000000" });
80 | 
81 |     expect(party.utxos.at(0)).to.deep.contain({
82 |       value: 10000000000n,
83 |       assets: []
84 |     });
85 |     expect(ErgoBox.validate(party.utxos.at(0))).to.be.true;
86 | 
87 |     expect(party.utxos).to.have.length(1);
88 |     expect(addBalanceSpy).toHaveBeenCalledTimes(1);
89 |   });
90 | });
91 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/party/keyedMockChainParty.ts:
--------------------------------------------------------------------------------
 1 | import { randomBytes } from "@fleet-sdk/crypto";
 2 | import { ErgoHDKey } from "@fleet-sdk/wallet";
 3 | import type { MockChain } from "../mockChain";
 4 | import { MockChainParty } from "./mockChainParty";
 5 | 
 6 | export class KeyedMockChainParty extends MockChainParty {
 7 |   private readonly _key: ErgoHDKey;
 8 | 
 9 |   constructor(chain: MockChain, name?: string) {
10 |     const seed = randomBytes(32);
11 |     const key = ErgoHDKey.fromMasterSeed(seed);
12 |     super(chain, key.address, name);
13 | 
14 |     this._key = key;
15 |   }
16 | 
17 |   get key(): ErgoHDKey {
18 |     return this._key;
19 |   }
20 | }
21 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/party/mockChainParty.ts:
--------------------------------------------------------------------------------
  1 | import {
  2 |   type Amount,
  3 |   type BoxCandidate,
  4 |   type NonMandatoryRegisters,
  5 |   type OneOrMore,
  6 |   type TokenAmount,
  7 |   utxoSum
  8 | } from "@fleet-sdk/common";
  9 | import { type Box, type ErgoAddress, SAFE_MIN_BOX_VALUE } from "@fleet-sdk/core";
 10 | import { stringifyBalance } from "../balancePrinting";
 11 | import type { MockChain } from "../mockChain";
 12 | import { MockUTxOCollection } from "../mockUtxoCollection";
 13 | 
 14 | export type MockUTxOInput = OneOrMore<BoxCandidate<Amount>> | OneOrMore<Box<Amount>>;
 15 | 
 16 | export type AddBalance = {
 17 |   nanoergs?: Amount;
 18 |   tokens?: TokenAmount<Amount>[];
 19 | };
 20 | 
 21 | export type PartyBalance = {
 22 |   nanoergs: bigint;
 23 |   tokens: TokenAmount<bigint>[];
 24 | };
 25 | 
 26 | export abstract class MockChainParty {
 27 |   private readonly _name?: string;
 28 |   private readonly _utxos: MockUTxOCollection;
 29 |   private readonly _address: ErgoAddress;
 30 |   private readonly _ergoTree: string;
 31 |   private readonly _chain: MockChain;
 32 | 
 33 |   constructor(chain: MockChain, address: ErgoAddress, name?: string) {
 34 |     this._chain = chain;
 35 |     this._address = address;
 36 |     this._name = name;
 37 | 
 38 |     this._ergoTree = this._address.ergoTree;
 39 |     this._utxos = new MockUTxOCollection();
 40 |   }
 41 | 
 42 |   get address(): ErgoAddress {
 43 |     return this._address;
 44 |   }
 45 | 
 46 |   get name(): string {
 47 |     return this._name || this._address.encode();
 48 |   }
 49 | 
 50 |   get utxos(): MockUTxOCollection {
 51 |     return this._utxos;
 52 |   }
 53 | 
 54 |   get ergoTree(): string {
 55 |     return this._ergoTree;
 56 |   }
 57 | 
 58 |   get chain(): MockChain {
 59 |     return this._chain;
 60 |   }
 61 | 
 62 |   get balance(): PartyBalance {
 63 |     const summary = utxoSum(this._utxos.toArray());
 64 | 
 65 |     return { nanoergs: summary.nanoErgs, tokens: summary.tokens };
 66 |   }
 67 | 
 68 |   addUTxOs(utxos: MockUTxOInput): MockChainParty {
 69 |     this._utxos.add(utxos);
 70 | 
 71 |     return this;
 72 |   }
 73 | 
 74 |   /**
 75 |    * Syntax sugar for `addUTxOs`
 76 |    * @param utxos
 77 |    * @returns
 78 |    */
 79 |   withUTxOs(utxos: MockUTxOInput): MockChainParty {
 80 |     return this.addUTxOs(utxos);
 81 |   }
 82 | 
 83 |   addBalance(
 84 |     balance: AddBalance,
 85 |     additionalRegisters?: NonMandatoryRegisters
 86 |   ): MockChainParty {
 87 |     this.addUTxOs({
 88 |       value: balance.nanoergs || SAFE_MIN_BOX_VALUE,
 89 |       assets: balance.tokens || [],
 90 |       ergoTree: this._ergoTree,
 91 |       creationHeight: this._chain.height,
 92 |       additionalRegisters: additionalRegisters || {}
 93 |     });
 94 | 
 95 |     return this;
 96 |   }
 97 | 
 98 |   /**
 99 |    * Syntax sugar for `addBalance`
100 |    * @param utxos
101 |    * @returns
102 |    */
103 |   withBalance(
104 |     balance: AddBalance,
105 |     additionalRegisters?: NonMandatoryRegisters
106 |   ): MockChainParty {
107 |     return this.addBalance(balance, additionalRegisters);
108 |   }
109 | 
110 |   toString(width = 50): string {
111 |     return stringifyBalance(this.balance, this.name, width, this._chain.assetsMetadata);
112 |   }
113 | }
114 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/party/nonKeyedMockChainParty.spec.ts:
--------------------------------------------------------------------------------
 1 | import { ErgoAddress, FEE_CONTRACT } from "@fleet-sdk/core";
 2 | import { describe, expect, it } from "vitest";
 3 | import { MockChain } from "../mockChain";
 4 | import { NonKeyedMockChainParty } from "./nonKeyedMockChainParty";
 5 | 
 6 | describe("Keyed mock chain party", () => {
 7 |   const chain = new MockChain();
 8 |   it("Should create a non-keyed party", () => {
 9 |     const nonKeyedNamedParty = new NonKeyedMockChainParty(chain, FEE_CONTRACT, "miner");
10 |     const address = ErgoAddress.fromErgoTree(FEE_CONTRACT);
11 | 
12 |     expect(nonKeyedNamedParty.name).to.be.equal("miner");
13 |     expect(nonKeyedNamedParty.utxos).to.have.length(0);
14 |     expect(nonKeyedNamedParty.address.encode()).to.be.equal(address.encode());
15 |     expect(nonKeyedNamedParty.ergoTree).to.be.equal(FEE_CONTRACT);
16 |     expect(nonKeyedNamedParty.ergoTree).to.be.equal(nonKeyedNamedParty.address.ergoTree);
17 | 
18 |     const nonKeyedUnnamedParty = new NonKeyedMockChainParty(chain, FEE_CONTRACT);
19 |     expect(nonKeyedUnnamedParty.name).to.be.equal(nonKeyedUnnamedParty.address.encode());
20 |   });
21 | 
22 |   it("Should throw if creating a non-keyed party without an ErgoTree", () => {
23 |     expect(() => new NonKeyedMockChainParty(chain, {} as unknown as string)).to.throw(
24 |       "A non-keyed party needs a valid ErgoTree to be instantiated."
25 |     );
26 |   });
27 | });
28 | 


--------------------------------------------------------------------------------
/packages/mock-chain/src/party/nonKeyedMockChainParty.ts:
--------------------------------------------------------------------------------
 1 | import { assert, type HexString } from "@fleet-sdk/common";
 2 | import { ErgoAddress } from "@fleet-sdk/core";
 3 | import type { MockChain } from "../mockChain";
 4 | import { MockChainParty } from "./mockChainParty";
 5 | 
 6 | export class NonKeyedMockChainParty extends MockChainParty {
 7 |   constructor(chain: MockChain, ergoTree: HexString, name?: string) {
 8 |     assert(
 9 |       typeof ergoTree === "string",
10 |       "A non-keyed party needs a valid ErgoTree to be instantiated."
11 |     );
12 | 
13 |     const address = ErgoAddress.fromErgoTree(ergoTree);
14 |     super(chain, address, name);
15 |   }
16 | }
17 | 


--------------------------------------------------------------------------------
/packages/serializer/CHANGELOG.md:
--------------------------------------------------------------------------------
  1 | # @fleet-sdk/serializer
  2 | 
  3 | ## 0.8.2
  4 | 
  5 | ### Patch Changes
  6 | 
  7 | - 66d6fc9: Fix `ZigZag` encoding for 32-bit integers
  8 | - 1c8541a: Fix signed `SByte` parsing
  9 | - Updated dependencies [9a244b5]
 10 | - Updated dependencies [1b07c4a]
 11 |   - @fleet-sdk/crypto@0.8.2
 12 | 
 13 | ## 0.8.0
 14 | 
 15 | ### Patch Changes
 16 | 
 17 | - a47a5fd: Fix types for nested `SColl[SBytes]` creation.
 18 | - Updated dependencies [36adc61]
 19 | - Updated dependencies [b2ce7aa]
 20 |   - @fleet-sdk/common@0.8.0
 21 |   - @fleet-sdk/crypto@0.8.0
 22 | 
 23 | ## 0.7.0
 24 | 
 25 | ### Minor Changes
 26 | 
 27 | - 9fceb6f: **🚨 BREAKING CHANGE**: `decode` function now returns `SConstant` instead of data directly
 28 | - 62025c4: Introduce `stypeof` utility function
 29 | 
 30 | ## 0.6.4
 31 | 
 32 | ### Patch Changes
 33 | 
 34 | - Updated dependencies [504974e]
 35 |   - @fleet-sdk/common@0.6.4
 36 |   - @fleet-sdk/crypto@0.6.4
 37 | 
 38 | ## 0.5.0
 39 | 
 40 | ### Patch Changes
 41 | 
 42 | - 9dd0b55: Export `SigmaByteWriter` and `SigmaByteReader` classes
 43 | - Updated dependencies [6ecfd2e]
 44 |   - @fleet-sdk/crypto@0.5.0
 45 | 
 46 | ## 0.4.1
 47 | 
 48 | ### Patch Changes
 49 | 
 50 | - d6ef248: Fix: export `decode()` function
 51 | - Updated dependencies [28e3467]
 52 |   - @fleet-sdk/common@0.4.1
 53 |   - @fleet-sdk/crypto@0.4.1
 54 | 
 55 | ## 0.4.0
 56 | 
 57 | ### Minor Changes
 58 | 
 59 | - 0089ed6: Deprecate `parse()` function
 60 | - 0089ed6: Add `decode()` function
 61 | 
 62 | ### Patch Changes
 63 | 
 64 | - Updated dependencies [70aea89]
 65 | - Updated dependencies [253d37a]
 66 |   - @fleet-sdk/crypto@0.4.0
 67 | 
 68 | ## 0.3.4
 69 | 
 70 | ### Patch Changes
 71 | 
 72 | - 9f02ca0: Fix ESM and CJS modules export
 73 | - Updated dependencies [9f02ca0]
 74 |   - @fleet-sdk/common@0.3.4
 75 |   - @fleet-sdk/crypto@0.3.4
 76 | 
 77 | ## 0.3.2
 78 | 
 79 | ### Patch Changes
 80 | 
 81 | - Updated dependencies [1d6e259]
 82 | - Updated dependencies [1d6e259]
 83 |   - @fleet-sdk/common@0.3.2
 84 |   - @fleet-sdk/crypto@0.3.2
 85 | 
 86 | ## 0.2.3
 87 | 
 88 | ### Patch Changes
 89 | 
 90 | - 37cdfdd: Add support for possibly `undefined` values to `parse()` function when in `safe` mode.
 91 | - 1e0edd4: Fix missing `types` export in `package.json`
 92 | - Updated dependencies [1e0edd4]
 93 | - Updated dependencies [65d5b33]
 94 | - Updated dependencies [514dcd2]
 95 |   - @fleet-sdk/common@0.2.3
 96 |   - @fleet-sdk/crypto@0.2.3
 97 | 
 98 | ## 0.2.2
 99 | 
100 | ### Patch Changes
101 | 
102 | - Updated dependencies [9cbd414]
103 |   - @fleet-sdk/common@0.2.2
104 |   - @fleet-sdk/crypto@0.2.2
105 | 
106 | ## 0.2.1
107 | 
108 | ### Patch Changes
109 | 
110 | - edf2830: Fix module exporting.
111 | - Updated dependencies [edf2830]
112 |   - @fleet-sdk/common@0.2.1
113 |   - @fleet-sdk/crypto@0.2.1
114 | 
115 | ## 0.2.0
116 | 
117 | ### Minor Changes
118 | 
119 | - 76d4c3d: Introduce `serializer` package.
120 | - cd877ce: Add embedded `SColl` support.
121 | - cd877ce: Add `SPair` type support.
122 | - e532fb8: Add type string representation.
123 | 
124 | ### Patch Changes
125 | 
126 | - Updated dependencies [5a79c57]
127 | - Updated dependencies [8a13a29]
128 | - Updated dependencies [a491ab9]
129 | - Updated dependencies [3236dd8]
130 | - Updated dependencies [9bd393b]
131 | - Updated dependencies [2ab9661]
132 | - Updated dependencies [2ab9661]
133 |   - @fleet-sdk/common@0.2.0
134 |   - @fleet-sdk/crypto@0.2.0
135 | 


--------------------------------------------------------------------------------
/packages/serializer/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2023 Nautilus Team
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/serializer/README.md:
--------------------------------------------------------------------------------
1 | # @fleet-sdk/serializer [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/serializer)](https://www.npmjs.com/package/@fleet-sdk/serializer)
2 | 
3 | Ergo constant serializer and parser.
4 | 


--------------------------------------------------------------------------------
/packages/serializer/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/serializer",
 3 |   "version": "0.8.2",
 4 |   "description": "Ergo constant serializer and parser.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "transactions",
31 |     "serialization"
32 |   ],
33 |   "scripts": {
34 |     "build": "tsup --config ../../tsup.config.ts"
35 |   },
36 |   "dependencies": {
37 |     "@fleet-sdk/common": "workspace:^",
38 |     "@fleet-sdk/crypto": "workspace:^"
39 |   },
40 |   "engines": {
41 |     "node": ">=18"
42 |   },
43 |   "files": [
44 |     "dist",
45 |     "!**/*.spec.*",
46 |     "!**/*.json",
47 |     "!tests",
48 |     "CHANGELOG.md",
49 |     "LICENSE",
50 |     "README.md"
51 |   ]
52 | }
53 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/bigint.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { bigIntToHex, hexToBigInt } from "./bigint";
 3 | 
 4 | describe("BigInt <> bytes serialization", () => {
 5 |   it("Should convert a bigint value to a hex string", () => {
 6 |     expect(bigIntToHex(-54417895017443177n)).toBe("ff3eab367a0f9097");
 7 | 
 8 |     expect(bigIntToHex(170892133397465074381480318756786823280n)).toBe(
 9 |       "008090a0b0c0d0e0f00010203040506070"
10 |     );
11 |     expect(bigIntToHex(-169390233523473389081894288674981388176n)).toBe(
12 |       "8090a0b0c0d0e0f00010203040506070"
13 |     );
14 | 
15 |     expect(bigIntToHex(1207883114728849269100423775319436127n)).toBe(
16 |       "00e8a13c46cdde58d442c8e45b9f2b5f"
17 |     );
18 |     expect(bigIntToHex(-518499127179672366370132270668500813n)).toBe(
19 |       "9c2404f2634ef40afccc320eed30b3"
20 |     );
21 |     expect(bigIntToHex(4n)).toBe("04");
22 |   });
23 | 
24 |   it("Should convert a hex string to a bigint value", () => {
25 |     expect(hexToBigInt("0e8a13c46cdde58d442c8e45b9f2b5f")).toBe(
26 |       1207883114728849269100423775319436127n
27 |     );
28 |     expect(hexToBigInt("9c2404f2634ef40afccc320eed30b3")).toBe(
29 |       -518499127179672366370132270668500813n
30 |     );
31 |   });
32 | });
33 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/bigint.ts:
--------------------------------------------------------------------------------
 1 | import { _0n, first } from "@fleet-sdk/common";
 2 | 
 3 | /**
 4 |  * Converts a hex string to bigint.
 5 |  * @param hex The hex string to be converted.
 6 |  * @returns The bigint value represented by the hex string.
 7 |  */
 8 | export function hexToBigInt(hex: string): bigint {
 9 |   // https://coolaj86.com/articles/convert-hex-to-decimal-with-js-bigints/
10 |   const value = BigInt(hex.length % 2 ? `0x0${hex}` : `0x${hex}`);
11 |   const highByte = Number.parseInt(hex.slice(0, 2), 16);
12 |   if (0x80 & highByte) return -negateAndMask(value);
13 | 
14 |   return value;
15 | }
16 | 
17 | /**
18 |  * Serializes a `BigInt` to a hex string
19 |  * @param value The bigint value to be serialized
20 |  * @returns Hex representation for the provided `number`.
21 |  */
22 | export function bigIntToHex(value: bigint): string {
23 |   // implementation inspired on
24 |   // https://coolaj86.com/articles/convert-decimal-to-hex-with-js-bigints/
25 |   const positive = value >= _0n;
26 |   let hex = (positive ? value : negateAndMask(value)).toString(16);
27 |   if (hex.length % 2) hex = `0${hex}`;
28 | 
29 |   if (positive && 0x80 & Number.parseInt(hex.slice(0, 2), 16)) {
30 |     return `00${hex}`;
31 |   }
32 | 
33 |   return hex;
34 | }
35 | 
36 | /**
37 |  * Returns the two’s complement of a bigint value.
38 |  * @param value The bigint value to negate.
39 |  * @returns The two’s complement of `number` as a bigint.
40 |  */
41 | export function negateAndMask(value: bigint): bigint {
42 |   let val = value;
43 |   const negative = val < _0n;
44 |   if (negative) val = -val; // turn into a positive number
45 | 
46 |   const bits = val.toString(2);
47 |   let len = bits.length; // convert to binary
48 |   const mod = len % 8;
49 | 
50 |   if (mod > 0) {
51 |     len += 8 - mod;
52 |   } else if (negative && first(bits) === "1" && bits.indexOf("1", 1) !== -1) {
53 |     len += 8;
54 |   }
55 | 
56 |   const mask = (1n << BigInt(len)) - 1n; // create a mask
57 |   return (~val & mask) + 1n; // invert bits, mask it, and add one
58 | }
59 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./sigmaByteReader";
2 | export * from "./sigmaByteWriter";
3 | export * from "./vlq";
4 | export * from "./zigZag";
5 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/numRanges.ts:
--------------------------------------------------------------------------------
 1 | export const MIN_U8 = 0x00;
 2 | export const MAX_U8 = 0xff;
 3 | 
 4 | export const MIN_I8 = -0x80;
 5 | export const MAX_I8 = 0x7f;
 6 | 
 7 | export const MIN_I16 = -0x8000;
 8 | export const MAX_I16 = 0x7fff;
 9 | 
10 | export const MIN_I32 = -0x80000000;
11 | export const MAX_I32 = 0x7fffffff;
12 | 
13 | export const MIN_I64 = -BigInt("0x8000000000000000");
14 | export const MAX_I64 = BigInt("0x7fffffffffffffff");
15 | 
16 | export const MIN_I256 = -BigInt(
17 |   "0x8000000000000000000000000000000000000000000000000000000000000000"
18 | );
19 | 
20 | export const MAX_I256 = BigInt(
21 |   "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
22 | );
23 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/sigmaByteReader.ts:
--------------------------------------------------------------------------------
 1 | import { isEmpty } from "@fleet-sdk/common";
 2 | import { type ByteInput, ensureBytes, hex } from "@fleet-sdk/crypto";
 3 | import { hexToBigInt } from "./bigint";
 4 | import { readBigVLQ, readVLQ } from "./vlq";
 5 | import { zigZag32, zigZag64 } from "./zigZag";
 6 | import { MAX_I8, MAX_U8 } from "./numRanges";
 7 | 
 8 | export class SigmaByteReader {
 9 |   readonly #bytes: Uint8Array;
10 |   #cursor: number;
11 | 
12 |   public get isEmpty(): boolean {
13 |     return isEmpty(this.#bytes);
14 |   }
15 | 
16 |   constructor(bytes: ByteInput) {
17 |     this.#bytes = ensureBytes(bytes);
18 |     this.#cursor = 0;
19 |   }
20 | 
21 |   public readBool(): boolean {
22 |     return this.readByte() === 0x01;
23 |   }
24 | 
25 |   public readBits(length: number): ArrayLike<boolean> {
26 |     const bits = new Array<boolean>(length);
27 |     let bitOffset = 0;
28 | 
29 |     for (let i = 0; i < length; i++) {
30 |       const bit = (this.#bytes[this.#cursor] >> bitOffset++) & 1;
31 |       bits[i] = bit === 1;
32 | 
33 |       if (bitOffset === 8) {
34 |         bitOffset = 0;
35 |         this.#cursor++;
36 |       }
37 |     }
38 | 
39 |     if (bitOffset > 0) this.#cursor++;
40 | 
41 |     return bits;
42 |   }
43 | 
44 |   public readByte(): number {
45 |     return this.#bytes[this.#cursor++];
46 |   }
47 | 
48 |   public readBytes(length: number): Uint8Array {
49 |     return this.#bytes.subarray(this.#cursor, (this.#cursor += length));
50 |   }
51 | 
52 |   public readVlq(): number {
53 |     return readVLQ(this);
54 |   }
55 | 
56 |   public readI8(): number {
57 |     const byte = this.readByte();
58 |     return byte > MAX_I8 ? byte - (MAX_U8 + 1) : byte;
59 |   }
60 | 
61 |   public readI16(): number {
62 |     return zigZag32.decode(readBigVLQ(this));
63 |   }
64 | 
65 |   public readI32(): number {
66 |     return zigZag32.decode(readBigVLQ(this));
67 |   }
68 | 
69 |   public readI64(): bigint {
70 |     return zigZag64.decode(readBigVLQ(this));
71 |   }
72 | 
73 |   public readI256(): bigint {
74 |     const len = readVLQ(this);
75 |     return hexToBigInt(hex.encode(this.readBytes(len)));
76 |   }
77 | }
78 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/zigZag.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it, test } from "vitest";
 2 | import { zigZag32, zigZag64 } from "./zigZag";
 3 | import fc from "fast-check";
 4 | import { MAX_I32, MAX_I64, MIN_I32, MIN_I64 } from "./numRanges";
 5 | 
 6 | describe("ZigZag 32-bit codec", () => {
 7 |   const tv = [
 8 |     { input: 0, output: 0n },
 9 |     { input: 1, output: 2n },
10 |     { input: -1, output: 1n },
11 |     { input: 0x3fffffff, output: 0x7ffffffen },
12 |     { input: 0x000000003fffffff, output: 0x000000007ffffffen },
13 |     { input: MAX_I32, output: 18446744073709551614n },
14 |     { input: MIN_I32, output: 18446744073709551615n }
15 |   ];
16 | 
17 |   test.each(tv)("Should encode %i", (t) => {
18 |     expect(zigZag32.encode(t.input)).to.be.equal(t.output);
19 |   });
20 | 
21 |   test.each(tv)("Should decode %i", (t) => {
22 |     expect(zigZag32.decode(t.output)).to.be.equal(t.input);
23 |   });
24 | 
25 |   test("Round-trip fuzzing", () => {
26 |     fc.assert(
27 |       fc.property(fc.integer({ min: MIN_I32, max: MAX_I32 }), (n) => {
28 |         expect(zigZag32.decode(zigZag32.encode(n))).to.be.equal(n);
29 |       })
30 |     );
31 |   });
32 | });
33 | 
34 | describe("ZigZag 64-bit codec", () => {
35 |   const tv = [
36 |     { input: 0n, output: 0n },
37 |     { input: 1n, output: 2n },
38 |     { input: -1n, output: 1n },
39 |     { input: 0x3fffffffn, output: 0x7ffffffen },
40 |     { input: 0x000000003fffffffn, output: 0x000000007ffffffen },
41 |     { input: MAX_I64, output: 18446744073709551614n },
42 |     { input: MIN_I64, output: 18446744073709551615n }
43 |   ];
44 | 
45 |   test.each(tv)("Should encode %i", (t) => {
46 |     expect(zigZag64.encode(t.input)).to.be.equal(t.output);
47 |   });
48 | 
49 |   test.each(tv)("Should decode %i", (t) => {
50 |     expect(zigZag64.decode(t.output)).to.be.equal(t.input);
51 |   });
52 | 
53 |   test("Round-trip fuzzing", () => {
54 |     fc.assert(
55 |       fc.property(fc.bigInt({ min: MIN_I64, max: MAX_I64 }), (n) => {
56 |         expect(zigZag64.decode(zigZag64.encode(n))).to.be.equal(n);
57 |       })
58 |     );
59 |   });
60 | });
61 | 


--------------------------------------------------------------------------------
/packages/serializer/src/coders/zigZag.ts:
--------------------------------------------------------------------------------
 1 | import { _1n, _63n } from "@fleet-sdk/common";
 2 | 
 3 | /**
 4 |  * ZigZag encoding maps signed integers to unsigned integers so that numbers
 5 |  * with a small absolute value (for instance, -1) have a small variant encoded
 6 |  * value too. It does this in a way that "zig-zags" back and forth through the
 7 |  * positive and negative integers, so that -1 is encoded as 1, 1 is encoded as 2,
 8 |  * -2 is encoded as 3, and so on.
 9 |  * @see https://developers.google.com/protocol-buffers/docs/encoding#types
10 |  */
11 | 
12 | const _31n = BigInt(31);
13 | 
14 | const u64 = (v: bigint) => BigInt.asUintN(64, v);
15 | const i64 = (v: bigint) => BigInt.asIntN(64, v);
16 | const i32 = (v: bigint) => BigInt.asIntN(32, v);
17 | const u32 = (v: bigint) => BigInt.asUintN(32, v);
18 | 
19 | /**
20 |  * 32-bit ZigZag encoding.
21 |  */
22 | export const zigZag32 = {
23 |   encode: (input: bigint | number): bigint => {
24 |     const v = i32(BigInt(input));
25 |     return u64(i32(v << _1n) ^ i32(v >> _31n));
26 |   },
27 |   decode: (input: bigint): number => {
28 |     const v = u32(input);
29 |     return Number((v >> _1n) ^ -(v & _1n));
30 |   }
31 | };
32 | 
33 | /**
34 |  * 64-bit ZigZag encoding.
35 |  */
36 | export const zigZag64 = {
37 |   encode: (input: bigint): bigint => {
38 |     return u64((input << _1n) ^ (input >> _63n));
39 |   },
40 |   decode: (input: bigint): bigint => {
41 |     return i64((input >> _1n) ^ -(input & _1n));
42 |   }
43 | };
44 | 


--------------------------------------------------------------------------------
/packages/serializer/src/index.ts:
--------------------------------------------------------------------------------
1 | export { estimateVLQSize, SigmaByteReader, SigmaByteWriter } from "./coders";
2 | export { SConstant, parse, decode, stypeof } from "./sigmaConstant";
3 | export * from "./types";
4 | export * from "./serializers";
5 | 


--------------------------------------------------------------------------------
/packages/serializer/src/serializers/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./boxSerializer";
2 | export * from "./transactionSerializer";
3 | export * from "./dataSerializer";
4 | export * from "./typeSerializer";
5 | 


--------------------------------------------------------------------------------
/packages/serializer/src/serializers/transactionSerializer.spec.ts:
--------------------------------------------------------------------------------
 1 | import { blake2b256, hex } from "@fleet-sdk/crypto";
 2 | import { describe, expect, it } from "vitest";
 3 | import { unsignedTransactionVectors } from "../_test-vectors/transactionVectors";
 4 | import { serializeTransaction } from "./transactionSerializer";
 5 | 
 6 | describe("Transaction serializer", () => {
 7 |   it.each(unsignedTransactionVectors)("Should serialize [$name]", (tv) => {
 8 |     const bytes = serializeTransaction(tv.json).toBytes();
 9 | 
10 |     expect(hex.encode(bytes)).toBe(tv.hex);
11 |     expect(hex.encode(blake2b256(bytes))).toBe(tv.hash);
12 |   });
13 | });
14 | 


--------------------------------------------------------------------------------
/packages/serializer/src/serializers/transactionSerializer.ts:
--------------------------------------------------------------------------------
 1 | import {
 2 |   type Amount,
 3 |   type BoxCandidate,
 4 |   type DataInput,
 5 |   isDefined,
 6 |   type UnsignedInput
 7 | } from "@fleet-sdk/common";
 8 | import { SigmaByteWriter } from "../coders";
 9 | import { serializeBox } from "./boxSerializer";
10 | 
11 | export type MinimalUnsignedTransaction = {
12 |   inputs: readonly UnsignedInput[];
13 |   dataInputs: readonly DataInput[];
14 |   outputs: readonly BoxCandidate<Amount>[];
15 | };
16 | 
17 | export function serializeTransaction(
18 |   transaction: MinimalUnsignedTransaction
19 | ): SigmaByteWriter {
20 |   const writer = new SigmaByteWriter(100_000);
21 | 
22 |   // write inputs
23 |   writer.writeVLQ(transaction.inputs.length);
24 |   transaction.inputs.map((input) => writeInput(writer, input));
25 | 
26 |   // write data inputs
27 |   writer.writeVLQ(transaction.dataInputs.length);
28 |   transaction.dataInputs.map((dataInput) => writer.writeHex(dataInput.boxId));
29 | 
30 |   // write distinct token IDs
31 |   const distinctTokenIds = getDistinctTokenIds(transaction.outputs);
32 |   writer.writeVLQ(distinctTokenIds.length);
33 |   distinctTokenIds.map((tokenId) => writer.writeHex(tokenId));
34 | 
35 |   // write outputs
36 |   writer.writeVLQ(transaction.outputs.length);
37 |   transaction.outputs.map((output) => serializeBox(output, writer, distinctTokenIds));
38 | 
39 |   return writer;
40 | }
41 | 
42 | function writeInput(writer: SigmaByteWriter, input: UnsignedInput): void {
43 |   writer.writeHex(input.boxId);
44 |   writer.write(0); // empty proof
45 |   writeExtension(writer, input.extension);
46 | }
47 | 
48 | function writeExtension(
49 |   writer: SigmaByteWriter,
50 |   extension: Record<string, string | undefined>
51 | ): void {
52 |   const keys = Object.keys(extension);
53 |   let length = 0;
54 | 
55 |   for (const key of keys) {
56 |     if (isDefined(extension[key])) length++;
57 |   }
58 | 
59 |   writer.writeVLQ(length);
60 |   if (length === 0) return;
61 | 
62 |   for (const key of keys) {
63 |     const val = extension[key];
64 |     if (isDefined(val)) {
65 |       writer.writeVLQ(Number(key)).writeHex(val);
66 |     }
67 |   }
68 | }
69 | 
70 | function getDistinctTokenIds(outputs: readonly BoxCandidate<Amount>[]) {
71 |   const tokenIds = new Set<string>();
72 |   outputs.flatMap((output) => output.assets.map((asset) => tokenIds.add(asset.tokenId)));
73 | 
74 |   return Array.from(tokenIds);
75 | }
76 | 


--------------------------------------------------------------------------------
/packages/serializer/src/sigmaConstant.ts:
--------------------------------------------------------------------------------
  1 | import { assert, isUndefined } from "@fleet-sdk/common";
  2 | import { type ByteInput, hex } from "@fleet-sdk/crypto";
  3 | import { SigmaByteReader, SigmaByteWriter } from "./coders";
  4 | import { dataSerializer } from "./serializers/dataSerializer";
  5 | import { typeSerializer } from "./serializers/typeSerializer";
  6 | import type { SType } from "./types";
  7 | 
  8 | export const MAX_CONSTANT_LENGTH = 4096;
  9 | 
 10 | export class SConstant<D = unknown, T extends SType = SType> {
 11 |   readonly #type: T;
 12 |   readonly #data: D;
 13 | 
 14 |   constructor(type: T, data: D) {
 15 |     this.#type = type;
 16 |     this.#data = type.coerce(data) as D;
 17 |   }
 18 | 
 19 |   static from<D, T extends SType = SType>(bytes: ByteInput): SConstant<D, T> {
 20 |     assert(bytes.length > 0, "Empty constant bytes.");
 21 | 
 22 |     const reader = new SigmaByteReader(bytes);
 23 |     const type = typeSerializer.deserialize(reader);
 24 |     const data = dataSerializer.deserialize(type, reader);
 25 | 
 26 |     return new SConstant(type as T, data as D);
 27 |   }
 28 | 
 29 |   get type(): T {
 30 |     return this.#type;
 31 |   }
 32 | 
 33 |   get data(): D {
 34 |     return this.#data;
 35 |   }
 36 | 
 37 |   toBytes(): Uint8Array {
 38 |     const writer = new SigmaByteWriter(MAX_CONSTANT_LENGTH);
 39 |     typeSerializer.serialize(this.type, writer);
 40 |     dataSerializer.serialize(this.data, this.type, writer);
 41 | 
 42 |     return writer.toBytes();
 43 |   }
 44 | 
 45 |   toHex(): string {
 46 |     return hex.encode(this.toBytes());
 47 |   }
 48 | }
 49 | 
 50 | /**
 51 |  * Decodes a byte input into a Sigma constant of type `SConstant<D, T>`.
 52 |  *
 53 |  * @template D - The data type of the constant.
 54 |  * @template T - The type of the constant.
 55 |  * @param value - The value to decode.
 56 |  * @returns The decoded constant or `undefined` if the value is `undefined` or decoding fails.
 57 |  */
 58 | export function decode<D = unknown, T extends SType = SType>(
 59 |   value?: ByteInput
 60 | ): SConstant<D, T> | undefined {
 61 |   if (value === undefined) return;
 62 | 
 63 |   try {
 64 |     return SConstant.from<D, T>(value);
 65 |   } catch {
 66 |     return;
 67 |   }
 68 | }
 69 | 
 70 | /**
 71 |  * Returns the `SType` of the given value.
 72 |  *
 73 |  * @param value - The value to check the SType of.
 74 |  * @returns The SType of the value, or `undefined` if the value is `undefined` or
 75 |  * deserialization fails.
 76 |  */
 77 | export function stypeof(value?: ByteInput): SType | undefined {
 78 |   if (!value) return;
 79 | 
 80 |   try {
 81 |     return typeSerializer.deserialize(new SigmaByteReader(value));
 82 |   } catch {
 83 |     return;
 84 |   }
 85 | }
 86 | 
 87 | /** @deprecated use `decode` instead */
 88 | export function parse<T>(constant: ByteInput): T;
 89 | /** @deprecated use `decode` instead */
 90 | export function parse<T>(constant: ByteInput, mode: "strict"): T;
 91 | /** @deprecated use `decode` instead */
 92 | export function parse<T>(constant: ByteInput | undefined, mode: "safe"): T | undefined;
 93 | /** @deprecated use `decode` instead */
 94 | export function parse<T>(
 95 |   constant: ByteInput | undefined,
 96 |   mode: "strict" | "safe" = "strict"
 97 | ) {
 98 |   if (mode === "strict") return SConstant.from<T>(constant ?? "").data;
 99 |   if (!constant) return;
100 | 
101 |   try {
102 |     return SConstant.from<T>(constant).data;
103 |   } catch {
104 |     return;
105 |   }
106 | }
107 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/base.ts:
--------------------------------------------------------------------------------
 1 | export abstract class SType<I = unknown, O = I> {
 2 |   abstract get code(): number;
 3 |   abstract get embeddable(): boolean;
 4 | 
 5 |   coerce(data: I): O {
 6 |     // a bit hacky but most of types will not need a specific coercion function.
 7 |     return data as unknown as O;
 8 |   }
 9 | 
10 |   abstract toString(): string;
11 | }
12 | 
13 | export abstract class SMonomorphicType<I, O = I> extends SType<I, O> {
14 |   abstract get code(): number;
15 | 
16 |   get embeddable(): boolean {
17 |     return false;
18 |   }
19 | }
20 | 
21 | export abstract class SPrimitiveType<I, O = I> extends SMonomorphicType<I, O> {
22 |   abstract get code(): number;
23 | 
24 |   override get embeddable(): boolean {
25 |     return true;
26 |   }
27 | }
28 | 
29 | export abstract class SGenericType<T extends SType | SType[]> extends SType {
30 |   readonly #internalType: T;
31 | 
32 |   constructor(type: T) {
33 |     super();
34 |     this.#internalType = type;
35 |   }
36 | 
37 |   abstract get code(): number;
38 | 
39 |   get elementsType(): T {
40 |     return this.#internalType;
41 |   }
42 | 
43 |   get embeddable(): boolean {
44 |     return false;
45 |   }
46 | }
47 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/constructors.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import {
 3 |   SBigInt,
 4 |   SBool,
 5 |   SByte,
 6 |   SColl,
 7 |   SGroupElement,
 8 |   SInt,
 9 |   SLong,
10 |   SPair,
11 |   SShort,
12 |   SSigmaProp,
13 |   SUnit
14 | } from "./constructors";
15 | import { SCollType, STupleType } from "./generics";
16 | import { SUnitType } from "./monomorphics";
17 | import {
18 |   SBigIntType,
19 |   SBoolType,
20 |   SByteType,
21 |   SGroupElementType,
22 |   SIntType,
23 |   SLongType,
24 |   SShortType,
25 |   SSigmaPropType
26 | } from "./primitives";
27 | 
28 | describe("Constructor proxies", () => {
29 |   it("Should correspond to proxied type", () => {
30 |     expect(new SByteType()).to.be.instanceof(SByte).and.to.be.instanceOf(SByteType);
31 |     expect(new SBoolType()).to.be.instanceof(SBool).and.to.be.instanceOf(SBoolType);
32 |     expect(new SShortType()).to.be.instanceof(SShort).and.to.be.instanceOf(SShortType);
33 |     expect(new SIntType()).to.be.instanceof(SInt).and.to.be.instanceOf(SIntType);
34 |     expect(new SLongType()).to.be.instanceof(SLong).and.to.be.instanceOf(SLongType);
35 |     expect(new SBigIntType()).to.be.instanceof(SBigInt).and.to.be.instanceOf(SBigIntType);
36 |     expect(new SGroupElementType())
37 |       .to.be.instanceof(SGroupElement)
38 |       .and.to.be.instanceOf(SGroupElementType);
39 |     expect(new SSigmaPropType())
40 |       .to.be.instanceof(SSigmaProp)
41 |       .and.to.be.instanceOf(SSigmaPropType);
42 |     expect(new SUnitType()).to.be.instanceof(SUnit).and.to.be.instanceOf(SUnitType);
43 |     expect(new SCollType(new SByteType()))
44 |       .to.be.instanceof(SColl)
45 |       .and.to.be.instanceOf(SCollType);
46 |     expect(new STupleType([SBool(), SInt()]))
47 |       .to.be.instanceof(SPair)
48 |       .and.to.be.instanceOf(STupleType);
49 |   });
50 | });
51 | 
52 | describe("SPair constructor", () => {
53 |   it("Should throw if params contains different types", () => {
54 |     // biome-ignore lint/suspicious/noExplicitAny: <explanation>
55 |     expect(() => SPair(SBool(true) as any, SBool() as any)).to.throw(
56 |       "Invalid tuple declaration."
57 |     );
58 |     // biome-ignore lint/suspicious/noExplicitAny: <explanation>
59 |     expect(() => SPair(SBool() as any, SBool(true)) as any).to.throw(
60 |       "Invalid tuple declaration."
61 |     );
62 |   });
63 | });
64 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/descriptors.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import {
 3 |   SBigInt,
 4 |   SBool,
 5 |   SByte,
 6 |   SGroupElement,
 7 |   SInt,
 8 |   SLong,
 9 |   SShort,
10 |   SSigmaProp
11 | } from "./constructors";
12 | import { getPrimitiveType } from "./descriptors";
13 | 
14 | describe("Primitive type object fetching", () => {
15 |   it("Should return correct types", () => {
16 |     expect(getPrimitiveType(0x01)).to.be.instanceOf(SBool);
17 |     expect(getPrimitiveType(0x02)).to.be.instanceOf(SByte);
18 |     expect(getPrimitiveType(0x03)).to.be.instanceOf(SShort);
19 |     expect(getPrimitiveType(0x04)).to.be.instanceOf(SInt);
20 |     expect(getPrimitiveType(0x05)).to.be.instanceOf(SLong);
21 |     expect(getPrimitiveType(0x06)).to.be.instanceOf(SBigInt);
22 |     expect(getPrimitiveType(0x07)).to.be.instanceOf(SGroupElement);
23 |     expect(getPrimitiveType(0x08)).to.be.instanceOf(SSigmaProp);
24 |   });
25 | 
26 |   it("Should throw if type code is not a primitive", () => {
27 |     expect(() => getPrimitiveType(0xff)).to.throw();
28 |   });
29 | });
30 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/generics.ts:
--------------------------------------------------------------------------------
 1 | import { hex } from "@fleet-sdk/crypto";
 2 | import { SGenericType, type SType } from "./base";
 3 | import { descriptors } from "./descriptors";
 4 | 
 5 | export class SCollType<T extends SType = SType> extends SGenericType<T> {
 6 |   get code(): number {
 7 |     return descriptors.coll.code;
 8 |   }
 9 | 
10 |   override coerce<I, O>(elements: I[]): O[] | Uint8Array {
11 |     if (
12 |       this.elementsType.code === descriptors.byte.code &&
13 |       !(elements instanceof Uint8Array)
14 |     ) {
15 |       return typeof elements === "string"
16 |         ? hex.decode(elements)
17 |         : Uint8Array.from(elements as ArrayLike<number>);
18 |     }
19 | 
20 |     return elements.map((el) => this.elementsType.coerce(el)) as O[];
21 |   }
22 | 
23 |   toString(): string {
24 |     return `SColl[${this.elementsType.toString()}]`;
25 |   }
26 | }
27 | 
28 | export class STupleType<T extends SType[] = SType[]> extends SGenericType<T> {
29 |   get code(): number {
30 |     return descriptors.tuple.code;
31 |   }
32 | 
33 |   override coerce<I, O>(elements: I[]): O[] {
34 |     const output = new Array(elements.length);
35 |     for (let i = 0; i < elements.length; i++) {
36 |       output[i] = this.elementsType[i].coerce(elements[i]);
37 |     }
38 | 
39 |     return output;
40 |   }
41 | 
42 |   toString(): string {
43 |     return `(${this.elementsType.map((el) => el.toString()).join(", ")})`;
44 |   }
45 | }
46 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/index.ts:
--------------------------------------------------------------------------------
 1 | export * from "./base";
 2 | export * from "./primitives";
 3 | export { isColl, isTuple } from "./descriptors";
 4 | export * from "./generics";
 5 | export * from "./monomorphics";
 6 | export {
 7 |   SByte,
 8 |   SBool,
 9 |   SShort,
10 |   SInt,
11 |   SLong,
12 |   SBigInt,
13 |   SGroupElement,
14 |   SSigmaProp,
15 |   SUnit,
16 |   SColl,
17 |   SPair
18 | } from "./constructors";
19 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/monomorphics.ts:
--------------------------------------------------------------------------------
 1 | import { SMonomorphicType } from "./base";
 2 | 
 3 | export class SUnitType extends SMonomorphicType<undefined> {
 4 |   get code(): 0x62 {
 5 |     return 0x62;
 6 |   }
 7 | 
 8 |   toString(): string {
 9 |     return "SUnit";
10 |   }
11 | }
12 | 


--------------------------------------------------------------------------------
/packages/serializer/src/types/primitives.ts:
--------------------------------------------------------------------------------
 1 | import { ensureBigInt } from "@fleet-sdk/common";
 2 | import { hex } from "@fleet-sdk/crypto";
 3 | import type { SConstant } from "../sigmaConstant";
 4 | import { SPrimitiveType } from "./base";
 5 | import type { BigIntInput, ByteInput } from "./constructors";
 6 | 
 7 | export class SBoolType extends SPrimitiveType<boolean> {
 8 |   get code(): 0x01 {
 9 |     return 0x01;
10 |   }
11 | 
12 |   toString(): string {
13 |     return "SBool";
14 |   }
15 | }
16 | 
17 | export class SByteType extends SPrimitiveType<number> {
18 |   get code(): 0x02 {
19 |     return 0x02;
20 |   }
21 | 
22 |   toString(): string {
23 |     return "SByte";
24 |   }
25 | }
26 | 
27 | export class SShortType extends SPrimitiveType<number> {
28 |   get code(): 0x03 {
29 |     return 0x03;
30 |   }
31 | 
32 |   toString(): string {
33 |     return "SShort";
34 |   }
35 | }
36 | 
37 | export class SIntType extends SPrimitiveType<number> {
38 |   get code(): 0x04 {
39 |     return 0x04;
40 |   }
41 | 
42 |   toString(): string {
43 |     return "SInt";
44 |   }
45 | }
46 | 
47 | export class SLongType extends SPrimitiveType<BigIntInput, bigint> {
48 |   get code(): 0x05 {
49 |     return 0x05;
50 |   }
51 | 
52 |   override coerce(data: BigIntInput): bigint {
53 |     return ensureBigInt(data);
54 |   }
55 | 
56 |   toString(): string {
57 |     return "SLong";
58 |   }
59 | }
60 | 
61 | export class SBigIntType extends SPrimitiveType<string | bigint, bigint> {
62 |   get code(): number {
63 |     return 0x06;
64 |   }
65 | 
66 |   override coerce(data: BigIntInput): bigint {
67 |     return ensureBigInt(data);
68 |   }
69 | 
70 |   toString(): string {
71 |     return "SBigInt";
72 |   }
73 | }
74 | 
75 | export class SGroupElementType extends SPrimitiveType<ByteInput, Uint8Array> {
76 |   get code(): 0x07 {
77 |     return 0x07;
78 |   }
79 | 
80 |   override coerce(data: ByteInput): Uint8Array {
81 |     return typeof data === "string" ? hex.decode(data) : data;
82 |   }
83 | 
84 |   toString(): string {
85 |     return "SGroupElement";
86 |   }
87 | }
88 | 
89 | export class SSigmaPropType extends SPrimitiveType<SConstant<Uint8Array>> {
90 |   get code(): 0x08 {
91 |     return 0x08;
92 |   }
93 | 
94 |   toString(): string {
95 |     return "SSigmaProp";
96 |   }
97 | }
98 | 


--------------------------------------------------------------------------------
/packages/wallet/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2023 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/packages/wallet/README.md:
--------------------------------------------------------------------------------
1 | # @fleet-sdk/wallet [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/wallet)](https://www.npmjs.com/package/@fleet-sdk/wallet)
2 | 
3 | Key management and signature for Ergo Platform.
4 | 


--------------------------------------------------------------------------------
/packages/wallet/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/wallet",
 3 |   "version": "0.8.2",
 4 |   "description": "Key management and signature for Ergo Platform.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     },
19 |     "./wordlists": {
20 |       "types": "./dist/wordlists.d.ts",
21 |       "import": "./dist/wordlists.mjs",
22 |       "require": "./dist/wordlists.js"
23 |     }
24 |   },
25 |   "sideEffects": false,
26 |   "repository": "github:fleet-sdk/fleet",
27 |   "license": "MIT",
28 |   "publishConfig": {
29 |     "access": "public",
30 |     "provenance": true
31 |   },
32 |   "keywords": [
33 |     "ergo",
34 |     "blockchain",
35 |     "transactions",
36 |     "serialization"
37 |   ],
38 |   "scripts": {
39 |     "build": "tsup --config ../../tsup.config.ts  --entry ./src/index.ts --entry ./src/wordlists.ts"
40 |   },
41 |   "dependencies": {
42 |     "@fleet-sdk/common": "workspace:^",
43 |     "@fleet-sdk/core": "workspace:^",
44 |     "@fleet-sdk/crypto": "workspace:^",
45 |     "@fleet-sdk/serializer": "workspace:^",
46 |     "@noble/curves": "^1.8.1",
47 |     "@scure/bip32": "^1.6.2",
48 |     "@scure/bip39": "^1.5.4"
49 |   },
50 |   "engines": {
51 |     "node": ">=18"
52 |   },
53 |   "files": [
54 |     "dist",
55 |     "!**/*.spec.*",
56 |     "!**/*.json",
57 |     "!tests",
58 |     "CHANGELOG.md",
59 |     "LICENSE",
60 |     "README.md"
61 |   ]
62 | }
63 | 


--------------------------------------------------------------------------------
/packages/wallet/src/_test-vectors/keyVectors.ts:
--------------------------------------------------------------------------------
 1 | export const keyAddressesTestVectors = [
 2 |   {
 3 |     mnemonic:
 4 |       "brown acid reason sponsor fix defense pair kit private front next drip fire clip student",
 5 |     addresses: [
 6 |       "9hjEquNmETqhFvnng9s8sRZ9HFFB169jubBfdfKqt5DWTjNEPWQ",
 7 |       "9fdGiKo71ijaXESLxghxq9c9o7pF966ah4ncdS9PAgWD9EouPnL",
 8 |       "9g9Be8LM8vXe4GqtVDr5QQrQqxtuU1yLmUWN3BGc717RoyQkfKA"
 9 |     ]
10 |   },
11 |   {
12 |     // https://github.com/ergoplatform/ergo/issues/1627
13 |     mnemonic:
14 |       "race relax argue hair sorry riot there spirit ready fetch food hedgehog hybrid mobile pretty",
15 |     addresses: [
16 |       "9eYMpbGgBf42bCcnB2nG3wQdqPzpCCw5eB1YaWUUen9uCaW3wwm",
17 |       "9hbDtY893BDSDowLQMhHG1zvMj97aZ4Dhn5e9waepPp85ZqszAJ",
18 |       "9fvZwUVgZRQ1D9fnWo9htki1QbUHPyayz3aZ4PKfZPFgiVTQSUS",
19 |       "9hsnY5hUAsjjb3awB8SgwPyxhDoxaxuNWZzqvgCfgnPFZTqY6NQ",
20 |       "9iJe5heD3mvMPm6yi6rtZAzXVjZ1Sm12Y5LZb9P7YcYXp1hkd5N",
21 |       "9hdCRgAYyrf5fkHkQ9MtZu1bt2K1yosSQXUx4YZcSDamAc6wbwN",
22 |       "9eYwqmHR2q6HYQtn4qtgtvFx1KGYcdkJoXn9MTcZDkAGbo5MF2r",
23 |       "9i4yUcMTH7GGPPBegt2ZwWMnUaMbYm8243dYS8f6rTEVyQ9Uq3b",
24 |       "9gaWSGquk7XjdcfsVzDYeYbY79atawsmB7p8JrBX2ThXR1EGWs6",
25 |       "9hBfMj3DdnHSwuEZrMP376WwmNZZvMrtdunxiWbsuw54yL6XM7g",
26 |       "9g8eCLchHRE9BiLFwVUBLKj8U81R7QsAg9iFZsq6yv9vzYAJrb4",
27 |       "9fS2xETSc6tU6TVSqZZjhSFEdKAFpnXQ1iXGgNNcMFVwyUYh4jQ",
28 |       "9egGo9ixEhXSrvfUTBJfTtEzwieiqw7tQcutycmh2PE9GtTxPNw",
29 |       "9gE2q8ge3gmv2iThTz6AC5Sj2yPBGxNFMfpYGnrj3xG8ETfo5iN",
30 |       "9hui4xxga5SP5YLPH4kqNhWGXPr2rnTuFJ4exreqyKhZVphp4rx",
31 |       "9fHfoB4tQByRqF4tAPWe6PpuLYSdWCoVx7L1zCpJDjP8mmG8JjL",
32 |       "9gSehpDSTfJYz96dbigfAkrNg6wfaXkkAbZHYw6i4Gd3WZ9H1iY",
33 |       "9iFgNga4FbK7Eypua1ftEigKByevCFMrk4uF9DivU1SD9WxbTBL",
34 |       "9gsPF8FYVkwojRYQnRxFLVqB4hvEJ93FXMBx738X8YEMZRdJD3R",
35 |       "9ffwgMqfr1FuigpWLRZCxVmoN11xJ9UsmTg1zztferWHRChgyMc",
36 |       "9exifR7rY8xe9DK6gkDWtLf36yds8qtY5JyeXHqSUyuCoPb7HjU"
37 |     ]
38 |   }
39 | ];
40 | 


--------------------------------------------------------------------------------
/packages/wallet/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./ergoHDKey";
2 | export * from "./mnemonic";
3 | export * from "./prover/prover";
4 | 


--------------------------------------------------------------------------------
/packages/wallet/src/mnemonic.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import { keyAddressesTestVectors } from "./_test-vectors/keyVectors";
 3 | import { generateMnemonic, validateMnemonic } from "./mnemonic";
 4 | 
 5 | describe("Mnemonic generation", () => {
 6 |   it("Should create a valid 12 word mnemonic", () => {
 7 |     const mnemonic = generateMnemonic(128);
 8 | 
 9 |     expect(mnemonic.split(" ")).to.have.length(12);
10 |     expect(validateMnemonic(mnemonic)).to.be.true;
11 |   });
12 | 
13 |   it("Should create a valid 15 word mnemonic by default", () => {
14 |     const mnemonic = generateMnemonic();
15 | 
16 |     expect(mnemonic.split(" ")).to.have.length(15);
17 |     expect(validateMnemonic(mnemonic)).to.be.true;
18 |   });
19 | 
20 |   it("Should create a valid 24 word mnemonic", () => {
21 |     const mnemonic = generateMnemonic(256);
22 | 
23 |     expect(mnemonic.split(" ")).to.have.length(24);
24 |     expect(validateMnemonic(mnemonic)).to.be.true;
25 |   });
26 | });
27 | 
28 | describe("Mnemonic validation", () => {
29 |   it("Should pass for valid mnemonics", () => {
30 |     for (const tv of keyAddressesTestVectors) {
31 |       expect(validateMnemonic(tv.mnemonic)).to.be.true;
32 |     }
33 |   });
34 | 
35 |   it("Should not pass for invalid mnemonics", () => {
36 |     expect(validateMnemonic("")).to.be.false;
37 |     expect(
38 |       validateMnemonic(
39 |         "brown reason sponsor fix defense pair kit private front next drip fire clip student"
40 |       )
41 |     ).to.be.false;
42 | 
43 |     expect(
44 |       validateMnemonic(
45 |         "brown acid reason sponsor fix defense pair kit private front next drip clip fire student"
46 |       )
47 |     ).to.be.false;
48 |   });
49 | });
50 | 


--------------------------------------------------------------------------------
/packages/wallet/src/mnemonic.ts:
--------------------------------------------------------------------------------
 1 | import { generateMnemonic as generate, validateMnemonic as validate } from "@scure/bip39";
 2 | import { wordlist as english } from "@scure/bip39/wordlists/english";
 3 | 
 4 | export function generateMnemonic(strength = 160, wordlist = english): string {
 5 |   return generate(wordlist, strength);
 6 | }
 7 | 
 8 | export function validateMnemonic(mnemonic: string, wordlist = english): boolean {
 9 |   return validate(mnemonic, wordlist);
10 | }
11 | 


--------------------------------------------------------------------------------
/packages/wallet/src/wordlists.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, it } from "vitest";
 2 | import {
 3 |   english,
 4 |   portuguese,
 5 |   simplifiedChinese,
 6 |   traditionalChinese,
 7 |   czech,
 8 |   french,
 9 |   italian,
10 |   japanese,
11 |   korean,
12 |   spanish
13 | } from "./wordlists";
14 | 
15 | describe("wordlists", () => {
16 |   const wordlistLength = 2048;
17 |   it("Should export all wordlists correctly", () => {
18 |     expect(english).to.have.length(wordlistLength);
19 |     expect(portuguese).to.have.length(wordlistLength);
20 |     expect(simplifiedChinese).to.have.length(wordlistLength);
21 |     expect(traditionalChinese).to.have.length(wordlistLength);
22 |     expect(czech).to.have.length(wordlistLength);
23 |     expect(french).to.have.length(wordlistLength);
24 |     expect(italian).to.have.length(wordlistLength);
25 |     expect(japanese).to.have.length(wordlistLength);
26 |     expect(korean).to.have.length(wordlistLength);
27 |     expect(spanish).to.have.length(wordlistLength);
28 |   });
29 | });
30 | 


--------------------------------------------------------------------------------
/packages/wallet/src/wordlists.ts:
--------------------------------------------------------------------------------
 1 | export { wordlist as english } from "@scure/bip39/wordlists/english";
 2 | export { wordlist as japanese } from "@scure/bip39/wordlists/japanese";
 3 | export { wordlist as korean } from "@scure/bip39/wordlists/korean";
 4 | export { wordlist as spanish } from "@scure/bip39/wordlists/spanish";
 5 | export { wordlist as simplifiedChinese } from "@scure/bip39/wordlists/simplified-chinese";
 6 | export { wordlist as traditionalChinese } from "@scure/bip39/wordlists/traditional-chinese";
 7 | export { wordlist as french } from "@scure/bip39/wordlists/french";
 8 | export { wordlist as italian } from "@scure/bip39/wordlists/italian";
 9 | export { wordlist as portuguese } from "@scure/bip39/wordlists/portuguese";
10 | export { wordlist as czech } from "@scure/bip39/wordlists/czech";
11 | 


--------------------------------------------------------------------------------
/plugins/ageusd/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2023 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/plugins/ageusd/README.md:
--------------------------------------------------------------------------------
 1 | # @fleet-sdk/ageusd-plugin [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/ageusd-plugin)](https://www.npmjs.com/package/@fleet-sdk/ageusd-plugin)
 2 | 
 3 | Fleet SDK plugin and utility functions for AgeUSD Protocol.
 4 | 
 5 | ## Installation
 6 | 
 7 | ```bash
 8 | npm install @fleet-sdk/ageusd-plugin
 9 | ```
10 | 
11 | ## Usage
12 | 


--------------------------------------------------------------------------------
/plugins/ageusd/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/ageusd-plugin",
 3 |   "version": "0.1.16",
 4 |   "description": "AgeUSD protocol plugin for Fleet SDK.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "babel fees",
31 |     "plugins"
32 |   ],
33 |   "dependencies": {
34 |     "@fleet-sdk/core": "workspace:^",
35 |     "@fleet-sdk/common": "workspace:^",
36 |     "@fleet-sdk/serializer": "workspace:^"
37 |   },
38 |   "devDependencies": {
39 |     "@fleet-sdk/mock-chain": "workspace:^"
40 |   },
41 |   "scripts": {
42 |     "build": "tsup --config ../../tsup.config.ts"
43 |   },
44 |   "engines": {
45 |     "node": ">=18"
46 |   },
47 |   "files": [
48 |     "src",
49 |     "dist",
50 |     "!**/*.spec.*",
51 |     "!**/*.json",
52 |     "!tests",
53 |     "CHANGELOG.md",
54 |     "LICENSE",
55 |     "README.md"
56 |   ]
57 | }
58 | 


--------------------------------------------------------------------------------
/plugins/ageusd/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./ageUsdBank";
2 | export * from "./sigmaUsdBank";
3 | export * from "./sigmaUsdParameters";
4 | export * from "./exchangePlugin";
5 | 


--------------------------------------------------------------------------------
/plugins/ageusd/src/sigmaUsdBank.spec.ts:
--------------------------------------------------------------------------------
 1 | import { describe, expect, test } from "vitest";
 2 | import { mockBankBox, mockOracleBox } from "./_tests/mocking";
 3 | import { SigmaUSDBank } from "./sigmaUsdBank";
 4 | import { SIGMA_USD_PARAMETERS } from "./sigmaUsdParameters";
 5 | 
 6 | describe("SigmaUSD Bank", () => {
 7 |   test("Constructor smoke test", () => {
 8 |     const bankBox = mockBankBox({
 9 |       reserveNanoergs: 1477201069508651n,
10 |       circulatingStableCoin: 160402193n,
11 |       circulatingReserveCoin: 1375438973n
12 |     });
13 |     const oracleBox = mockOracleBox(210526315n);
14 | 
15 |     const bank = new SigmaUSDBank(bankBox, oracleBox);
16 | 
17 |     expect(bank.bankBox).to.be.deep.equal(bankBox);
18 |     expect(bank.oracleBox).to.be.deep.equal(oracleBox);
19 |     expect(bank.params).to.be.deep.equal(SIGMA_USD_PARAMETERS);
20 |   });
21 | });
22 | 


--------------------------------------------------------------------------------
/plugins/ageusd/src/sigmaUsdBank.ts:
--------------------------------------------------------------------------------
1 | import { AgeUSDBank, type AgeUSDBankBox, type OracleBox } from "./ageUsdBank";
2 | import { SIGMA_USD_PARAMETERS } from "./sigmaUsdParameters";
3 | 
4 | export class SigmaUSDBank extends AgeUSDBank {
5 |   constructor(bankBox: AgeUSDBankBox, oracleBox: OracleBox) {
6 |     super(bankBox, oracleBox, SIGMA_USD_PARAMETERS);
7 |   }
8 | }
9 | 


--------------------------------------------------------------------------------
/plugins/ageusd/src/sigmaUsdParameters.ts:
--------------------------------------------------------------------------------
 1 | import type { HexString } from "@fleet-sdk/common";
 2 | 
 3 | export type AgeUSDBankParametersTokens = Readonly<{
 4 |   stableCoinId: HexString;
 5 |   reserveCoinId: HexString;
 6 |   nftId: HexString;
 7 | }>;
 8 | 
 9 | export type AgeUSDBankOracleParameters = Readonly<{
10 |   nftId: HexString;
11 |   decimals?: number;
12 | }>;
13 | 
14 | export type AgeUSDBankParameters = Readonly<{
15 |   contract: HexString;
16 |   minReserveRatio: bigint;
17 |   maxReserveRatio: bigint;
18 |   defaultReserveCoinPrice: bigint;
19 |   minBoxValue: bigint;
20 |   coolingOffHeight: number;
21 |   tokens: AgeUSDBankParametersTokens;
22 |   oracle: AgeUSDBankOracleParameters;
23 | }>;
24 | 
25 | export const SIGMA_USD_PARAMETERS: AgeUSDBankParameters = {
26 |   contract:
27 |     "102a0400040004000e20011d3364de07e5a26f0c4eef0852cddb387039a921b7154ef3cab22c6eda887f0400040204020400040004020500050005c8010500050005feffffffffffffffff0105000580897a05000580897a040405c80104c0933805c00c0580a8d6b907050005c8010580dac40905000500040404040500050005a0060101050005a0060100040004000e20239c170b7e82f94e6b05416f14b8a2a57e0bfff0e3c93f4abbcd160b6a5b271ad801d601db6501fed1ec9591b172017300d821d602b27201730100d603938cb2db63087202730200017303d604b2a5730400d605c17204d606db6308a7d607b27206730500d6088c720702d609db63087204d60ab27209730600d60b8c720a02d60c947208720bd60db27206730700d60e8c720d02d60fb27209730800d6108c720f02d61194720e7210d612e4c6a70505d613e4c672040505d614e4c6a70405d615e4c672040405d616b2a5730900d617e4c672160405d61895720c730a7217d61995720c7217730bd61ac1a7d61be4c672160505d61c9de4c672020405730cd61da2a1721a9c7214721c730dd61e9572119ca1721c95937214730e730f9d721d72147218d801d61e99721a721d9c9593721e7310731195937212731273139d721e72127219d61f9d9c721e7e7314057315d6209c7215721cd6219591a3731673177318d62295937220731972219d9c7205731a7220edededed7203ededededed927205731b93c27204c2a7edec720c7211efed720c7211ed939a720872129a720b7213939a720e72149a72107215edededed939a721472187215939a721272197213939a721a721b7205927215731c927213731deded938c720f018c720d01938c720a018c720701938cb27209731e00018cb27206731f000193721b9a721e958f721f7320f0721f721f957211959172187321927222732273239591721973249072227221927222732572037326938cb2db6308b2a4732700732800017329",
28 |   minBoxValue: BigInt(10000000),
29 |   defaultReserveCoinPrice: BigInt(1000000),
30 |   minReserveRatio: BigInt(400),
31 |   maxReserveRatio: BigInt(800),
32 |   coolingOffHeight: 460000,
33 |   tokens: {
34 |     stableCoinId: "03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04",
35 |     reserveCoinId: "003bd19d0187117f130b62e1bcab0939929ff5c7709f843c5c4dd158949285d0",
36 |     nftId: "7d672d1def471720ca5782fd6473e47e796d9ac0c138d9911346f118b2f6d9d9"
37 |   },
38 |   oracle: {
39 |     nftId: "011d3364de07e5a26f0c4eef0852cddb387039a921b7154ef3cab22c6eda887f",
40 |     decimals: 2
41 |   }
42 | };
43 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2022 capt-nemo429
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/README.md:
--------------------------------------------------------------------------------
 1 | # @fleet-sdk/babel-fees-plugin [![License](https://badgen.net/github/license/fleet-sdk/fleet/)](https://github.com/fleet-sdk/fleet/blob/master/LICENSE) [![npm](https://badgen.net/npm/v/@fleet-sdk/babel-fees-plugin)](https://www.npmjs.com/package/@fleet-sdk/babel-fees-plugin)
 2 | 
 3 | Fleet SDK plugin and utility functions for Babel Fees.
 4 | 
 5 | ## Installation
 6 | 
 7 | ```bash
 8 | npm install @fleet-sdk/babel-fees-plugin
 9 | ```
10 | 
11 | ## Usage Example
12 | 
13 | ```ts
14 | const tx = new TransactionBuilder(height)
15 |   .from(inputs)
16 |   // Use extend method to extend the transaction builder with plugins.
17 |   .extend(
18 |     // In this case, BabelSwapPlugin will swap the specified token
19 |     // amount for ERG, based on token price, and make it available.
20 |     // for use in the transaction.
21 |     BabelSwapPlugin(babelBox, {
22 |       tokenId: "03faf2cb329f2e90d6d23b58d91bbb6c046aa143261cc21f52fbe2824bfcbf04",
23 |       amount: "2" // amount of token units you want to swap for ERG
24 |     })
25 |   )
26 |   // BabelSwapPlugin will make swapped ERG available for use in any
27 |   // point of the transaction, in this example, we are using it to
28 |   // pay the mining fee and sending the excess to the change address.
29 |   .payMinFee()
30 |   .sendChangeTo(changeAddress)
31 |   .build();
32 | ```
33 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "@fleet-sdk/babel-fees-plugin",
 3 |   "version": "0.1.19",
 4 |   "description": "Babel Fees plugin for Fleet SDK.",
 5 |   "main": "./dist/index.js",
 6 |   "module": "./dist/index.mjs",
 7 |   "types": "./dist/index.d.ts",
 8 |   "exports": {
 9 |     ".": {
10 |       "import": {
11 |         "types": "./dist/index.d.mts",
12 |         "default": "./dist/index.mjs"
13 |       },
14 |       "require": {
15 |         "types": "./dist/index.d.ts",
16 |         "default": "./dist/index.js"
17 |       }
18 |     }
19 |   },
20 |   "sideEffects": false,
21 |   "repository": "github:fleet-sdk/fleet",
22 |   "license": "MIT",
23 |   "publishConfig": {
24 |     "access": "public",
25 |     "provenance": true
26 |   },
27 |   "keywords": [
28 |     "ergo",
29 |     "blockchain",
30 |     "babel fees",
31 |     "plugins"
32 |   ],
33 |   "dependencies": {
34 |     "@fleet-sdk/core": "workspace:^",
35 |     "@fleet-sdk/common": "workspace:^",
36 |     "@fleet-sdk/serializer": "workspace:^"
37 |   },
38 |   "scripts": {
39 |     "build": "tsup --config ../../tsup.config.ts"
40 |   },
41 |   "engines": {
42 |     "node": ">=18"
43 |   },
44 |   "files": [
45 |     "src",
46 |     "dist",
47 |     "!**/*.spec.*",
48 |     "!**/*.json",
49 |     "!tests",
50 |     "CHANGELOG.md",
51 |     "LICENSE",
52 |     "README.md"
53 |   ]
54 | }
55 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/src/constants.ts:
--------------------------------------------------------------------------------
1 | export const BABEL_FEE_CONTRACT_TEMPLATE_HASH =
2 |   "4e83fa68ef3ed9794bbab5d8799998a9e09fb10a0afe8d1bf928936dfd11c465";
3 | 
4 | export const BABEL_ERGOTREE_PREFIX = "100604000e20";
5 | export const BABEL_ERGOTREE_SUFFIX =
6 |   "0400040005000500d803d601e30004d602e4c6a70408d603e4c6a7050595e67201d804d604b2a5e4720100d605b2db63087204730000d606db6308a7d60799c1a7c17204d1968302019683050193c27204c2a7938c720501730193e4c672040408720293e4c672040505720393e4c67204060ec5a796830201929c998c7205029591b1720673028cb272067303000273047203720792720773057202";
7 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/src/index.ts:
--------------------------------------------------------------------------------
1 | export * from "./plugins";
2 | export * from "./utils";
3 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/src/plugins.ts:
--------------------------------------------------------------------------------
 1 | import { ensureBigInt } from "@fleet-sdk/common";
 2 | import {
 3 |   type Amount,
 4 |   type Box,
 5 |   ErgoUnsignedInput,
 6 |   type FleetPlugin,
 7 |   OutputBuilder,
 8 |   SAFE_MIN_BOX_VALUE,
 9 |   type TokenAmount
10 | } from "@fleet-sdk/core";
11 | import { SByte, SColl, SInt } from "@fleet-sdk/serializer";
12 | import { getTokenPrice, isBabelContractForTokenId, isValidBabelBox } from "./utils";
13 | 
14 | export function BabelSwapPlugin(
15 |   babelBox: Box<Amount>,
16 |   token: TokenAmount<Amount>
17 | ): FleetPlugin {
18 |   if (!isValidBabelBox(babelBox)) throw new Error("Invalid Babel Box.");
19 | 
20 |   if (!isBabelContractForTokenId(babelBox.ergoTree, token.tokenId)) {
21 |     throw new Error(
22 |       `The Babel Box '${babelBox.boxId}' is not compatible with Token ID '${token.tokenId}'.`
23 |     );
24 |   }
25 | 
26 |   const input = new ErgoUnsignedInput(babelBox);
27 |   const changeAmount = input.value - ensureBigInt(token.amount) * getTokenPrice(babelBox);
28 | 
29 |   if (changeAmount < SAFE_MIN_BOX_VALUE) {
30 |     throw new Error(
31 |       "The selected Babel Box does not have enough ERG to perform a swap for the selected amount of tokens."
32 |     );
33 |   }
34 | 
35 |   return ({ addInputs, addOutputs }) => {
36 |     const outputsLength = addOutputs(
37 |       new OutputBuilder(changeAmount, input.ergoTree)
38 |         .addTokens(input.assets)
39 |         .addTokens(token)
40 |         .setAdditionalRegisters({
41 |           R4: input.additionalRegisters.R4,
42 |           R5: input.additionalRegisters.R5,
43 |           R6: SColl(SByte, input.boxId)
44 |         })
45 |     );
46 | 
47 |     addInputs(input.setContextExtension({ 0: SInt(outputsLength - 1) }));
48 |   };
49 | }
50 | 


--------------------------------------------------------------------------------
/plugins/babel-fees/src/utils.ts:
--------------------------------------------------------------------------------
 1 | import { isHex } from "@fleet-sdk/common";
 2 | import type { Amount, Box, R4ToR5Registers } from "@fleet-sdk/core";
 3 | import { SConstant, SLong, SSigmaProp, stypeof } from "@fleet-sdk/serializer";
 4 | import { BABEL_ERGOTREE_PREFIX, BABEL_ERGOTREE_SUFFIX } from "./constants";
 5 | 
 6 | const TOKEN_ID_HEX_LENGTH = 64;
 7 | 
 8 | const BABEL_CONTRACT_LENGTH =
 9 |   BABEL_ERGOTREE_PREFIX.length + TOKEN_ID_HEX_LENGTH + BABEL_ERGOTREE_SUFFIX.length;
10 | 
11 | /**
12 |  * Get the the price for a token unit in Nanoergs
13 |  * @param babelBox
14 |  * @returns
15 |  */
16 | export function getTokenPrice(babelBox: Box<Amount>): bigint {
17 |   if (!isValidBabelBox(babelBox)) throw Error("Invalid babel box.");
18 |   return SConstant.from<bigint>(babelBox.additionalRegisters.R5).data;
19 | }
20 | 
21 | /**
22 |  * Build a Babel Fee contract for a given Token ID
23 |  * @param tokenId
24 |  * @returns returns a Babel Fee ErgoTree
25 |  */
26 | export function buildBabelContract(tokenId: string): string {
27 |   if (!isValidTokenId(tokenId)) throw new Error("Invalid Token ID");
28 |   return `${BABEL_ERGOTREE_PREFIX}${tokenId}${BABEL_ERGOTREE_SUFFIX}`;
29 | }
30 | 
31 | function isValidTokenId(tokenId: string): boolean {
32 |   return tokenId.length === TOKEN_ID_HEX_LENGTH && isHex(tokenId);
33 | }
34 | 
35 | /**
36 |  * Verify if an ErgoTree is a Babel Fee contract
37 |  * @param tokenId
38 |  * @returns
39 |  */
40 | export function isValidBabelContract(ergoTree: string): boolean {
41 |   return (
42 |     ergoTree.length === BABEL_CONTRACT_LENGTH &&
43 |     ergoTree.startsWith(BABEL_ERGOTREE_PREFIX) &&
44 |     ergoTree.endsWith(BABEL_ERGOTREE_SUFFIX)
45 |   );
46 | }
47 | 
48 | export type BabelBox = Box<Amount, R4ToR5Registers>;
49 | 
50 | /**
51 |  * Verify if a Box is a valid Babel Box
52 |  * @param tokenId
53 |  * @returns
54 |  */
55 | export function isValidBabelBox(box: Box<Amount>): box is BabelBox {
56 |   return (
57 |     stypeof(box.additionalRegisters.R4) instanceof SSigmaProp &&
58 |     stypeof(box.additionalRegisters.R5) instanceof SLong &&
59 |     isValidBabelContract(box.ergoTree)
60 |   );
61 | }
62 | 
63 | export function isBabelContractForTokenId(ergoTree: string, tokenId: string) {
64 |   if (!isValidBabelContract(ergoTree)) return false;
65 | 
66 |   const extractedTokenId = ergoTree.slice(
67 |     BABEL_ERGOTREE_PREFIX.length,
68 |     BABEL_ERGOTREE_PREFIX.length + TOKEN_ID_HEX_LENGTH
69 |   );
70 | 
71 |   return extractedTokenId === tokenId;
72 | }
73 | 
74 | export function extractTokenIdFromBabelContract(ergoTree: string): string {
75 |   if (!isValidBabelContract(ergoTree)) throw new Error("Invalid Babel Fee contract");
76 | 
77 |   return ergoTree.slice(
78 |     BABEL_ERGOTREE_PREFIX.length,
79 |     BABEL_ERGOTREE_PREFIX.length + TOKEN_ID_HEX_LENGTH
80 |   );
81 | }
82 | 


--------------------------------------------------------------------------------
/pnpm-workspace.yaml:
--------------------------------------------------------------------------------
1 | packages:
2 |   - "packages/*"
3 |   - "plugins/*"
4 | 


--------------------------------------------------------------------------------
/tsconfig.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "compilerOptions": {
 3 |     "target": "ESNext",
 4 |     "moduleResolution": "Node",
 5 |     "module": "ESNext",
 6 |     "declaration": true,
 7 |     "inlineSourceMap": false,
 8 |     "esModuleInterop": true,
 9 |     "resolveJsonModule": true,
10 |     "strict": true,
11 |     "noImplicitReturns": true,
12 |     "noFallthroughCasesInSwitch": true,
13 |     "traceResolution": false,
14 |     "listEmittedFiles": false,
15 |     "sourceMap": true,
16 |     "skipLibCheck": true,
17 |     "listFiles": false,
18 |     "pretty": true,
19 |     "lib": ["ESNext", "DOM"],
20 |     "typeRoots": ["node_modules/@types"],
21 |     "baseUrl": ".",
22 |     "paths": {
23 |       "_test-vectors": ["./packages/_test-vectors/"]
24 |     }
25 |   },
26 |   "compileOnSave": false,
27 |   "exclude": ["**/node_modules", "**/dist"]
28 | }
29 | 


--------------------------------------------------------------------------------
/tsup.config.ts:
--------------------------------------------------------------------------------
 1 | import { defineConfig } from "tsup";
 2 | 
 3 | export default defineConfig({
 4 |   entry: ["src/index.ts"],
 5 |   outDir: "./dist",
 6 |   splitting: false,
 7 |   treeshake: true,
 8 |   sourcemap: true,
 9 |   clean: true,
10 |   dts: { resolve: true },
11 |   format: ["esm", "cjs"]
12 | });
13 | 


--------------------------------------------------------------------------------
/vitest.config.ts:
--------------------------------------------------------------------------------
 1 | import viteTsConfigPaths from "vite-tsconfig-paths";
 2 | import { defineConfig } from "vitest/config";
 3 | 
 4 | export default defineConfig({
 5 |   plugins: [viteTsConfigPaths()],
 6 |   test: {
 7 |     coverage: {
 8 |       thresholds: {
 9 |         "100": true
10 |       },
11 |       provider: "v8",
12 |       reporter: ["text", "json", "html"],
13 |       exclude: [
14 |         "**/*.spec.ts",
15 |         "**/*.d.ts",
16 |         "**/*.bench.ts",
17 |         "**/*.test-d.ts",
18 |         "**/*.test.ts",
19 |         "**/*.config.*",
20 |         "**/dist/**",
21 |         "**/common/src/types/index.ts", // probably a vitest bug
22 |         "**/common/src/types/enums.ts", // no need to test enums directly
23 |         "**/src/index.ts"
24 |       ]
25 |     }
26 |   }
27 | });
28 | 


--------------------------------------------------------------------------------